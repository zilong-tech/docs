<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://zilong-tech.github.io/docs/docs/zookeeper/zookpeer%E5%85%A5%E9%97%A8.html"><meta property="og:site_name" content="子龙技术"><meta property="og:title" content="zookpeer 入门"><meta property="og:description" content="zookeeper是由雅虎创建，zookeeper并没有直接采用Paxos算法，而是采用了一种被称为ZAB（zookeeper Atomic Broadcast）的一致性协议。 ZooKeeper 是一个开源的分布式协调框架，zookeeper是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布/订阅、负载均衡、命名服务、分..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-02-15T03:36:38.000Z"><meta property="article:author" content="程序员子龙"><meta property="article:modified_time" content="2023-02-15T03:36:38.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"zookpeer 入门","image":[""],"dateModified":"2023-02-15T03:36:38.000Z","author":[{"@type":"Person","name":"程序员子龙"}]}</script><title>zookpeer 入门 | 子龙技术</title><meta name="description" content="zookeeper是由雅虎创建，zookeeper并没有直接采用Paxos算法，而是采用了一种被称为ZAB（zookeeper Atomic Broadcast）的一致性协议。 ZooKeeper 是一个开源的分布式协调框架，zookeeper是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布/订阅、负载均衡、命名服务、分...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/docs/assets/style-84ad0583.css" as="style"><link rel="stylesheet" href="/docs/assets/style-84ad0583.css">
    <link rel="modulepreload" href="/docs/assets/app-36fed76c.js"><link rel="modulepreload" href="/docs/assets/framework-2afc6763.js"><link rel="modulepreload" href="/docs/assets/zookpeer入门.html-a39453f6.js"><link rel="modulepreload" href="/docs/assets/zookpeer入门.html-a16eac1d.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container no-sidebar has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/docs/" class="brand"><img class="logo" src="/docs/logo.png" alt="子龙技术"><!----><span class="site-name hide-in-pad">子龙技术</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="nav-link" aria-label="并发编程"><span class="font-icon icon info" style=""></span>并发编程<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="nav-link" aria-label="网络编程"><span class="font-icon icon info" style=""></span>网络编程<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="分布式"><span class="title"><span class="font-icon icon info" style=""></span>分布式</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/docs/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/" class="nav-link" aria-label="分布式基础"><span class="font-icon icon creative" style=""></span>分布式基础<!----></a></li><li class="dropdown-item"><a href="/docs/zookeeper/" class="nav-link active" aria-label="zookeeper"><span class="font-icon icon creative" style=""></span>zookeeper<!----></a></li><li class="dropdown-item"><a href="/docs/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" class="nav-link" aria-label="分布式事务"><span class="font-icon icon creative" style=""></span>分布式事务<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="微服务"><span class="title"><span class="font-icon icon info" style=""></span>微服务</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/docs/SpringBoot/" class="nav-link" aria-label="SpringBoot"><span class="font-icon icon creative" style=""></span>SpringBoot<!----></a></li><li class="dropdown-item"><a href="/docs/SpringCloudAlibaba/" class="nav-link" aria-label="SpringCloudAlibaba"><span class="font-icon icon creative" style=""></span>SpringCloudAlibaba<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/docs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="nav-link" aria-label="设计模式"><span class="font-icon icon info" style=""></span>设计模式<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/Java/" class="nav-link" aria-label="Java"><span class="font-icon icon info" style=""></span>Java<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/JVM/" class="nav-link" aria-label="JVM"><span class="font-icon icon info" style=""></span>JVM<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="数据库"><span class="title"><span class="font-icon icon info" style=""></span>数据库</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/docs/Redis/" class="nav-link" aria-label="Redis"><span class="font-icon icon info" style=""></span>Redis<!----></a></li><li class="dropdown-item"><a href="/docs/MySQL/" class="nav-link" aria-label="MySQL"><span class="font-icon icon info" style=""></span>MySQL<!----></a></li><li class="dropdown-item"><a href="/docs/Mongodb/" class="nav-link" aria-label="Mongodb"><span class="font-icon icon info" style=""></span>Mongodb<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/docs/Mybatis/" class="nav-link" aria-label="Mybatis"><span class="font-icon icon info" style=""></span>Mybatis<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/Spring/" class="nav-link" aria-label="Spring"><span class="font-icon icon info" style=""></span>Spring<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="消息中间件"><span class="title"><span class="font-icon icon info" style=""></span>消息中间件</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/docs/Kafka/" class="nav-link" aria-label="Kafka"><span class="font-icon icon creative" style=""></span>Kafka<!----></a></li><li class="dropdown-item"><a href="/docs/RocketMQ/" class="nav-link" aria-label="RocketMQ"><span class="font-icon icon creative" style=""></span>RocketMQ<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/docs/%E9%AB%98%E5%B9%B6%E5%8F%91/" class="nav-link" aria-label="高并发"><span class="font-icon icon info" style=""></span>高并发<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/%E9%9D%A2%E8%AF%95/" class="nav-link" aria-label="面试"><span class="font-icon icon info" style=""></span>面试<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/%E5%B7%A5%E5%85%B7/" class="nav-link" aria-label="工具"><span class="font-icon icon info" style=""></span>工具<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/" class="nav-link" aria-label="开源项目"><span class="font-icon icon info" style=""></span>开源项目<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!----><!----><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><span class="font-icon icon discover" style=""></span>zookpeer 入门</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">程序员子龙</span></span><span property="author" content="程序员子龙"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-02-15T03:36:38.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 34 分钟</span><meta property="timeRequired" content="PT34M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><span class="page-category-item category2" role>Zookeeper</span><meta property="articleSection" content="Zookeeper"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容<button class="print-button" title="print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/zookeeper/zookpeer%E5%85%A5%E9%97%A8.html#集群角色" class="router-link-active router-link-exact-active toc-link level2">集群角色</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/zookeeper/zookpeer%E5%85%A5%E9%97%A8.html#会话-session" class="router-link-active router-link-exact-active toc-link level2">会话（Session）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/zookeeper/zookpeer%E5%85%A5%E9%97%A8.html#版本" class="router-link-active router-link-exact-active toc-link level2">版本</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/zookeeper/zookpeer%E5%85%A5%E9%97%A8.html#数据节点-znode" class="router-link-active router-link-exact-active toc-link level2">数据节点（Znode）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/zookeeper/zookpeer%E5%85%A5%E9%97%A8.html#znode-数据结构" class="router-link-active router-link-exact-active toc-link level2">znode 数据结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/zookeeper/zookpeer%E5%85%A5%E9%97%A8.html#创建命令" class="router-link-active router-link-exact-active toc-link level2">创建命令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/zookeeper/zookpeer%E5%85%A5%E9%97%A8.html#查询命令" class="router-link-active router-link-exact-active toc-link level2">查询命令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/zookeeper/zookpeer%E5%85%A5%E9%97%A8.html#集群角色-1" class="router-link-active router-link-exact-active toc-link level2">集群角色</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/zookeeper/zookpeer%E5%85%A5%E9%97%A8.html#zookeeper-leader-选举原理" class="router-link-active router-link-exact-active toc-link level2">Zookeeper Leader 选举原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/zookeeper/zookpeer%E5%85%A5%E9%97%A8.html#集群中的服务器状态" class="router-link-active router-link-exact-active toc-link level2">集群中的服务器状态</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/zookeeper/zookpeer%E5%85%A5%E9%97%A8.html#选举的过半机制防止脑裂" class="router-link-active router-link-exact-active toc-link level2">选举的过半机制防止脑裂</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h1><p>zookeeper是由雅虎创建，zookeeper并没有直接采用Paxos算法，而是采用了一种被称为ZAB（zookeeper Atomic Broadcast）的一致性协议。</p><p>ZooKeeper 是一个开源的分布式协调框架，zookeeper是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。</p><p>Zookeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><p>官方：https://zookeeper.apache.org/</p><p><img src="https://note.youdao.com/yws/public/resource/f0549278905bb988c831d6910c54143a/xmlnote/377392559C58477A871480537851D8BC/44781" alt=""></p><p>ZooKeeper本质上是一个分布式的小文件存储系统（Zookeeper=文件系统+监听机制）。提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理，从而用来维护和监控存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理、统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等功能。</p><p>Zookeeper从设计模式角度来理解：是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper 就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。</p><p>​ <img src="https://note.youdao.com/yws/public/resource/f0549278905bb988c831d6910c54143a/xmlnote/F572FEBA87D24A3294A744B5272DA2A2/44785" alt=""></p><p><strong>ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</strong></p><p>另外，ZooKeeper 将数据保存在内存中，性能是非常棒的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景）。</p><h1 id="zookeeper-特点" tabindex="-1"><a class="header-anchor" href="#zookeeper-特点" aria-hidden="true">#</a> ZooKeeper 特点</h1><ul><li><strong>顺序一致性：</strong> 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li><li><strong>原子性：</strong> 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li><li><strong>单一系统映像 ：</strong> 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li><li><strong>可靠性：</strong> 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li></ul><h1 id="zookeeper-典型应用场景" tabindex="-1"><a class="header-anchor" href="#zookeeper-典型应用场景" aria-hidden="true">#</a> ZooKeeper 典型应用场景</h1><p>ZooKeeper 概览中，我们介绍到使用其通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p><p>下面选 3 个典型的应用场景：</p><ol><li><strong>分布式锁</strong> ： 通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁。</li><li><strong>命名服务</strong> ：可以通过 ZooKeeper 的顺序节点生成全局唯一 ID</li><li><strong>数据发布/订阅</strong> ：通过 <strong>Watcher 机制</strong> 可以很方便地实现数据发布/订阅。当你将数据发布到 ZooKeeper 被监听的节点上，其他机器可通过监听 ZooKeeper 上节点的变化来实现配置的动态更新。</li></ol><p><strong>统一命名服务</strong></p><p>在分布式环境下，经常需要对应用/服务进行统一命名，便于识别。</p><p>例如：IP不容易记住，而域名容易记住。</p><p>​ <img src="https://note.youdao.com/yws/public/resource/f0549278905bb988c831d6910c54143a/xmlnote/F2A8F7FA79634561A04A2EA2AB9A5347/45267" alt=""></p><p>利用 ZooKeeper 顺序节点的特性，制作分布式的序列号生成器，或者叫 id 生成器。（分布式环境下使用作为数据库 id，另外一种是 UUID（缺点：没有规律）），ZooKeeper 可以生成有顺序的容易理解的同时支持分布式环境的编号。</p><p>​ / └── /order ├── /order-date1-000000000000001 ├── /order-date2-000000000000002 ├── /order-date3-000000000000003 ├── /order-date4-000000000000004 └── /order-date5-000000000000005</p><p><strong>数据发布/订阅</strong></p><p>数据发布/订阅的一个常见的场景是配置中心，发布者把数据发布到 ZooKeeper 的一个或一系列的节点上，供订阅者进行数据订阅，达到动态获取数据的目的。</p><p>配置信息一般有几个特点:</p><ol><li>数据量小的KV</li><li>数据内容在运行时会发生动态变化</li><li>集群机器共享，配置一致</li></ol><p>ZooKeeper 采用的是推拉结合的方式。</p><ol><li>推: 服务端会推给注册了监控节点的客户端 Watcher 事件通知</li><li>拉: 客户端获得通知后，然后主动到服务端拉取最新的数据</li></ol><p>​ <img src="https://note.youdao.com/yws/public/resource/f0549278905bb988c831d6910c54143a/xmlnote/E51E89C99C314A1EAC79524300578D97/45269" alt=""></p><p><strong>统一集群管理</strong></p><p>分布式环境中，实时掌握每个节点的状态是必要的，可根据节点实时状态做出一些调整。</p><p>ZooKeeper可以实现实时监控节点状态变化：</p><ul><li>可将节点信息写入ZooKeeper上的一个ZNode。</li><li>监听这个ZNode可获取它的实时状态变化。</li></ul><p>​ <img src="https://note.youdao.com/yws/public/resource/f0549278905bb988c831d6910c54143a/xmlnote/DEDA41D032784D66B4BDC2FB55291B18/45264" alt=""></p><p><strong>负载均衡</strong></p><p>在Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求</p><p>​ <img src="https://note.youdao.com/yws/public/resource/f0549278905bb988c831d6910c54143a/xmlnote/5D2F5F78BC28416EB449EC47B0310358/45265" alt=""></p><h1 id="zookeeper-核心概念" tabindex="-1"><a class="header-anchor" href="#zookeeper-核心概念" aria-hidden="true">#</a> Zookeeper 核心概念</h1><h2 id="集群角色" tabindex="-1"><a class="header-anchor" href="#集群角色" aria-hidden="true">#</a> 集群角色</h2><p>Leader：Leader服务器为客户端提供读写服务 Follower：Follower为客户端提供读服务 Observer：Observer为客户端提供读服务，不参与选举Leader，不参与事务投票，不影响写性能提高集群的读性能。</p><h2 id="会话-session" tabindex="-1"><a class="header-anchor" href="#会话-session" aria-hidden="true">#</a> 会话（Session）</h2><p>Session是指客户端会话，是客户端连接服务端的一个TCP长连接。服务端的Watch事件通知也是通过该TCP连接。</p><p>在client和server通信之前,首先需要建立连接,该连接称为session。连接建立后,如果发生连接超时、授权失败,或者显式关闭连接,连接便处于closed状态, 此时session结束。</p><p>Session 有一个属性叫做：<code>sessionTimeout</code> ，<code>sessionTimeout</code> 代表会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在<code>sessionTimeout</code>规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p><p>另外，在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 <code>sessionID</code>。由于 <code>sessionID</code>是 ZooKeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 <code>sessionID</code> 的，因此，无论是哪台服务器为客户端分配的 <code>sessionID</code>，都务必保证全局唯一。</p><h2 id="版本" tabindex="-1"><a class="header-anchor" href="#版本" aria-hidden="true">#</a> 版本</h2><p>zookeeper会对每一个Znode维护一个Stat的数据结构，Stat中记录了Znode的三个数据版本:</p><p>dataVersion（当前Znode的版本）每次对节点进行set操作，dataVersion的值都会增加1（即使设置的是相同的数据），可有效避免了数据更新时出现的先后顺序问题。</p><p>cversion（当前Znode子节点的版本）当znode的子节点有变化时，cversion 的值就会增加1。</p><p>aversion（当前Znode的ACL版本）</p><h1 id="数据模型" tabindex="-1"><a class="header-anchor" href="#数据模型" aria-hidden="true">#</a> 数据模型</h1><p>ZooKeeper 数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二级制序列。并且。每个节点还可以拥有 N 个子节点，最上层是根节点以“/”来代表。每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。并且，每个 znode 都一个唯一的路径标识。</p><p>ZooKeeper 数据模型的结构与 Unix 文件系统很类似，整体上可以看作是一棵树。都是由一系列使用斜杠&quot;/&quot;进行分割的路径表示，开发人员可以向这个节点中写入数据，也可以在节点下面创建子节点。</p><p>​ <img src="https://note.youdao.com/yws/public/resource/f0549278905bb988c831d6910c54143a/xmlnote/42FE45D9612741FE9120F6054B97AA6D/45253" alt=""></p><p>ZooKeeper的数据模型是层次模型，层次模型常见于文件系统。层次模型和key-value模型是两种主流的数据模型。ZooKeeper使用文件系统模型主要基于以下两点考虑:</p><ol><li>文件系统的树形结构便于表达数据之间的层次关系</li><li>文件系统的树形结构便于为不同的应用分配独立的命名空间( namespace )</li></ol><p>ZooKeeper的层次模型称作Data Tree，Data Tree的每个节点叫作Znode。不同于文件系统，每个节点都可以保存数据，每一个 ZNode 默认能够存储 1MB 的数据，每个 ZNode 都可以通过其路径唯一标识，每个节点都有一个版本(version)，版本从0开始计数。</p><h2 id="数据节点-znode" tabindex="-1"><a class="header-anchor" href="#数据节点-znode" aria-hidden="true">#</a> 数据节点（Znode）</h2><p>zookeeper将所有的数据存储在内存中，数据模型是一棵树（Znode Tree），由斜杆进行分割的路径，就是一个Znode，每个Znode上都会保存自己的数据内容，同时还会保存一些列的属性信息。</p><p>每个子目录项都被称作为 <strong>znode(目录节点)</strong>，和文件系统类似，我们能够自由的增加、删除 znode，在一个znode下增加、删除子znode。</p><p>在zookeeper中，Znode分为持久节点和临时节点，持久节点是指一旦创建，除非主动删除，否则这个Znode会一直在Zookeeper中，临时节点它的生命周期是跟会话绑定，一旦客户端会话失效，临时节点将会删除。另外，zookeeper可以为每个节点添加SEQUENTIAL属性，一旦有这个属性，那么节点就是一个有序节点。</p><p><img src="https://pica.zhimg.com/80/v2-751ec74691a5a91105992f7b2df804c1_720w.png" alt=""></p><p>有四种类型的znode：</p><p>1、PERSISTENT­持久化节点</p><p>客户端与zookeeper断开连接后，该节点依旧存在，只要不手动删除该节点，他将永远存在</p><p>2、 PERSISTENT_SEQUENTIAL­持久化顺序编号节点</p><p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号，子节点的名称还具有顺序性。比如 <code>/node1/app0000000001</code> 、<code>/node1/app0000000002</code> 。</p><p>3、EPHEMERAL­临时节点</p><p>客户端与zookeeper断开连接后，该节点被删除 ，临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定的，<strong>会话消失则节点消失</strong> 。并且，<strong>临时节点只能做叶子节点</strong> ，不能创建子节点。</p><p>4、EPHEMERAL_SEQUENTIAL­ 临时顺序编号节点</p><p>客户端与zookeeper断开连接后，该节点被删除，子节点的名称还具有顺序性。</p><p>5、Container 节点（3.5.3 版本新增，如果Container节点下面没有子节点，则Container节点 在未来会被Zookeeper自动清除,定时任务默认60s 检查一次）</p><p>6、TTL 节点( 默认禁用，只能通过系统配置 <em>zookeeper.extendedTypesEnabled=true</em> 开启，不稳 定)</p><p><img src="https://pic1.zhimg.com/80/v2-ed40027bf87d7951a58ed2ba6d582df3_720w.png" alt=""></p><p>客户端注册监听它关心的任意节点，或者目录节点及递归子目录节点 1. 如果注册的是对某个节点的监听，则当这个节点被删除，或者被修改时，对应的客户端将被通 知2. 如果注册的是对某个目录的监听，则当这个目录有子节点被创建，或者有子节点被删除，对应 的客户端将被通知 3. 如果注册的是对某个目录的递归子节点进行监听，则当这个目录下面的任意子节点有目录结构 的变化（有子节点被创建，或被删除)或者根节点有数据变化时，对应的客户端将被通知。 注意：所有的通知都是一次性的，及无论是对节点还是对目录进行的监听，一旦触发，对应的监 听即被移除。递归子节点，监听是对所有子节点的，所以，每个子节点下面的事件同样只会被触 发一次。</p><h2 id="znode-数据结构" tabindex="-1"><a class="header-anchor" href="#znode-数据结构" aria-hidden="true">#</a> znode 数据结构</h2><p>每个 znode 由 2 部分组成:</p><ul><li><strong>stat</strong> ：状态信息</li><li><strong>data</strong> ： 节点存放的数据的具体内容</li></ul><p>查下节点数据</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>zk: localhost:2181<span class="token punctuation">(</span>CONNECTED<span class="token punctuation">)</span> <span class="token number">4</span><span class="token punctuation">]</span> get /testnode
somedata
cZxid <span class="token operator">=</span> 0x39
ctime <span class="token operator">=</span> Mon Jun <span class="token number">27</span> <span class="token number">20</span>:43:20 CST <span class="token number">2022</span>
mZxid <span class="token operator">=</span> 0x39
mtime <span class="token operator">=</span> Mon Jun <span class="token number">27</span> <span class="token number">20</span>:43:20 CST <span class="token number">2022</span>
pZxid <span class="token operator">=</span> 0x39
cversion <span class="token operator">=</span> <span class="token number">0</span>
dataVersion <span class="token operator">=</span> <span class="token number">0</span>
aclVersion <span class="token operator">=</span> <span class="token number">0</span>
ephemeralOwner <span class="token operator">=</span> 0x0
dataLength <span class="token operator">=</span> <span class="token number">8</span>
numChildren <span class="token operator">=</span> <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看节点状态</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>zk: localhost:2181<span class="token punctuation">(</span>CONNECTED<span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token function">stat</span> /testnode
cZxid <span class="token operator">=</span> 0x39
ctime <span class="token operator">=</span> Mon Jun <span class="token number">27</span> <span class="token number">20</span>:43:20 CST <span class="token number">2022</span>
mZxid <span class="token operator">=</span> 0x39
mtime <span class="token operator">=</span> Mon Jun <span class="token number">27</span> <span class="token number">20</span>:43:20 CST <span class="token number">2022</span>
pZxid <span class="token operator">=</span> 0x39
cversion <span class="token operator">=</span> <span class="token number">0</span>
dataVersion <span class="token operator">=</span> <span class="token number">0</span>
aclVersion <span class="token operator">=</span> <span class="token number">0</span>
ephemeralOwner <span class="token operator">=</span> 0x0
dataLength <span class="token operator">=</span> <span class="token number">8</span>
numChildren <span class="token operator">=</span> <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于zk来说，每次的变化都会产生一个唯一的事务id，zxid（ZooKeeper Transaction Id），通过zxid，可以确定更新操作的先后顺序。例如，如果zxid1小于zxid2，说明zxid1操作先于zxid2发生，zxid对于整个zk都是唯一的，即使操作的是不同的znode。</p><table><thead><tr><th>znode 状态信息</th><th>解释</th></tr></thead><tbody><tr><td>cZxid</td><td>create ZXID，即该数据节点被创建时的事务 id</td></tr><tr><td>ctime</td><td>create time，即该节点的创建时间</td></tr><tr><td>mZxid</td><td>modified ZXID，即该节点最终一次更新时的事务 id</td></tr><tr><td>mtime</td><td>modified time，即该节点最后一次的更新时间</td></tr><tr><td>pZxid</td><td>该节点的子节点列表最后一次修改时的事务 id，只有子节点列表变更才会更新 pZxid，子节点内容变更不会更新</td></tr><tr><td>cversion</td><td>子节点版本号，当前节点的子节点每次变化时值增加 1</td></tr><tr><td>dataVersion</td><td>数据节点内容版本号，节点创建时为 0，每更新一次节点内容(不管内容有无变化)该版本号的值增加 1</td></tr><tr><td>aclVersion</td><td>节点的 ACL 版本号，表示该节点 ACL 信息变更次数</td></tr><tr><td>ephemeralOwner</td><td>创建该临时节点的会话的 sessionId；如果当前节点为持久节点，则 ephemeralOwner=0</td></tr><tr><td>dataLength</td><td>数据节点内容长度</td></tr><tr><td>numChildren</td><td>当前节点的子节点个数</td></tr></tbody></table><h1 id="监听通知机制" tabindex="-1"><a class="header-anchor" href="#监听通知机制" aria-hidden="true">#</a> 监听通知机制</h1><p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。Watcher（事件监听器），zookeeper允许用户在指定节点上注册watcher，并且在一些特定事件触发的时候，zookeeper服务端会将事件通知到感兴趣的客户端上去，该机制是zookeeper实现分布式协调服务的重要特性。</p><p><img src="https://javaguide.cn/assets/watche机制.f523bd89.png" alt=""></p><p>客户端注册监听它关心的任意节点，或者目录节点及递归子目录节点</p><ol><li>如果注册的是对某个节点的监听，则当这个节点被删除，或者被修改时，对应的客户端将被通知</li><li>如果注册的是对某个目录的监听，则当这个目录有子节点被创建，或者有子节点被删除，对应 的客户端将被通知</li><li>如果注册的是对某个目录的递归子节点进行监听，则当这个目录下面的任意子节点有目录结构 的变化（有子节点被创建，或被删除）或者根节点有数据变化时，对应的客户端将被通知。 注意：所有的通知都是一次性的，及无论是对节点还是对目录进行的监听，一旦触发，对应的监 听即被移除。递归子节点，监听是对所有子节点的，所以，每个子节点下面的事件同样只会被触 发一次。</li></ol><ul><li>一个Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户端，以便通知它们。</li><li>Zookeeper采用了 Watcher机制实现数据的发布订阅功能，多个订阅者可同时监听某一特定主题对象，当该主题对象的自身状态发生变化时例如节点内容改变、节点下的子节点列表改变等，会实时、主动通知所有订阅者。</li><li>watcher机制事件上与观察者模式类似，也可看作是一种观察者模式在分布式场景下的实现方式。</li></ul><p>watcher的过程：</p><ol><li>客户端向服务端注册watcher</li><li>服务端事件发生触发watcher</li><li>客户端回调watcher得到触发事件情况</li></ol><p>注意：Zookeeper中的watch机制，必须客户端先去服务端注册监听，这样事件发送才会触发监听，通知给客户端。</p><p>支持的事件类型：</p><ul><li>None: 连接建立事件</li><li>NodeCreated： 节点创建</li><li>NodeDeleted： 节点删除</li><li>NodeDataChanged：节点数据变化</li><li>NodeChildrenChanged：子节点列表变化</li><li>DataWatchRemoved：节点监听被移除</li><li>ChildWatchRemoved：子节点监听被移除</li></ul><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>一次性触发</td><td>watcher是一次性的，一旦被触发就会移除，再次使用时需要重新注册</td></tr><tr><td>客户端顺序回调</td><td>watcher回调是顺序串行执行的，只有回调后客户端才能看到最新的数据状态。一个watcher回调逻辑不应该太多，以免影响别的watcher执行</td></tr><tr><td>轻量级</td><td>WatchEvent是最小的通信单位，结构上只包含通知状态、事件类型和节点路径，并不会告诉数据节点变化前后的具体内容</td></tr><tr><td>时效性</td><td>watcher只有在当前session彻底失效时才会无效，若在session有效期内快速重连成功，则watcher依然存在，仍可接收到通知；</td></tr></tbody></table><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>#监听节点数据的变化 
get -w path  stat -w path 
#监听子节点增减的变化 
ls -w path          
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​</p><p>应用场景：</p><p>在dubbo框架中，客户端和服务端注册watcher，当服务端节点发生变化时候，同时通知客户端，客户端更新本地服务列表</p><p><img src="https://pic1.zhimg.com/80/v2-e37393dbda6cfab1c88e0e8e0c9701e3_720w.png" alt=""></p><p>针对节点的监听：一定事件触发，对应的注册立刻被移除，所以事件监听是一次性的</p><h1 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h1><h2 id="创建命令" tabindex="-1"><a class="header-anchor" href="#创建命令" aria-hidden="true">#</a> 创建命令</h2><p>#创建一个非顺序的持久化节点 create [‐s] [‐e] [‐c] [‐t ttl] path [data] [acl]</p><p>中括号为可选项，没有则默认创建持久化节点</p><p>-s: 顺序节点</p><p>-e: 临时节点</p><p>-c: 容器节点</p><p>-t: 可以给节点添加过期时间，默认禁用，需要通过系统参数启用</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>#创建持久节点
create /test‐node  some‐data

#创建一个临时节点
create -e /test/tmp  tem-data

#创建临时有序节点 
create -e -s /servers/host  xxx              

#创建一个顺序节点
create -s /test/aaa  aaa-data

#创建容器节点   
create -c /container  

#创建ttl节点 
create -t 10 /ttl     
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​</p><p>容器节点主要用来容纳字节点，如果没有给其创建子节点，容器节点表现和持久化节点一样，如果给容器节点创建了子节点，后续又把子节点清空，容器节点也会被zookeeper删除。</p><h2 id="查询命令" tabindex="-1"><a class="header-anchor" href="#查询命令" aria-hidden="true">#</a> 查询命令</h2><ul><li>列出节点 ls</li></ul><p>ls [-s] [-w] [-R] path</p><p>-w 添加一个 watch（监视器）</p><p>-s 列举出节点详情</p><p>-R 列举出节点的级联节点</p><ul><li>获取节点信息 get</li></ul><p>get [-s] [-w] path</p><p>get /test‐node</p><p>-w 添加一个 watch（监视器）</p><p>-s 列举出节点详情</p><p>查看节点状态信息同时查看数据</p><p><img src="https://pic1.zhimg.com/80/v2-ea83ed88a43d2325f55b4e5ab5ddccce_720w.png" alt=""></p><p>根据状态数据中的版本号有并发修改数据实现乐观锁的功能</p><p>比如： 客户端首先获取版本信息</p><p><img src="https://pic3.zhimg.com/80/v2-6a325bdd3c3f063f78299200bb7254f8_720w.png" alt=""></p><p>当前的数据版本dataVersion是 0， 这时客户端 用 set 命令修改数据的时候可以把版本号带上</p><p>如果在执行上面 set命令前， 有人修改了数据，zookeeper 会递增版本号， 这个时候，如果再用以前的版本号去修改，将会导致修改失败，报如下错误</p><p>​ <img src="https://note.youdao.com/yws/public/resource/16ab5da92ee89d93f948dc57762b7ae6/xmlnote/48A6D222488E416089D749699947D771/25519" alt="0"></p><p>创建子节点， 这里要注意，zookeeper是以节点组织数据的，没有相对路径这么一说，所以，所有的节点一定是以 / 开头。</p><p>create /test-node/test-sub-node</p><p>查看子节点信息，比如根节点下面的所有子节点， 加一个大写 R 可以查看递归子节点列表</p><p><img src="https://pic2.zhimg.com/80/v2-6dc31cf924691b874b30d10086ed1aec_720w.png" alt=""></p><ul><li>检查状态 stat</li></ul><p>stat [-w] path</p><p>-w 添加一个 watch（监视器）</p><p>stat /test‐node</p><p><img src="https://pic3.zhimg.com/80/v2-a24f3b36fcef581032d980166780313c_720w.png" alt=""></p><p>cZxid：创建znode的事务ID（Zxid的值）。 mZxid：最后修改znode的事务ID。 pZxid：最后添加或删除子节点的事务ID（子节点列表发生变化才会发生改变）。 ctime：znode创建时间。 mtime：znode最近修改时间。 dataVersion：znode的当前数据版本。 cversion：znode的子节点结果集版本（一个节点的子节点增加、删除都会影响这个版本）。 aclVersion：表示对此znode的acl版本。 ephemeralOwner：znode是临时znode时，表示znode所有者的 session ID。 如果znode不是临时znode，则该字段设置为零。 dataLength：znode数据字段的长度。 numChildren：znode的子znode的数量。</p><ul><li>修改节点</li></ul><p>set [‐s] [‐v version] path data</p><p>set /test‐node some‐data‐changed</p><ul><li>删除节点</li></ul><p>delete [-v version] path</p><p>级联删除 delete deleteall path [-b batch size]</p><ul><li>事件监听机制</li></ul><p><code>get -w /path // 注册监听的同时获取数据</code></p><p><code>stat -w /path // 对节点进行监听，且获取元数据信息</code></p><p><img src="https://pic2.zhimg.com/80/v2-d2608df48e084e05f2eea29652931c51_720w.png" alt=""></p><p>针对目录的监听，如下图，目录的变化，会触发事件，且一旦触发，对应的监听也会被移除，后续对节点的创建没有触发监听事件</p><p><code>ls -w /path</code></p><p><img src="https://note.youdao.com/yws/public/resource/16ab5da92ee89d93f948dc57762b7ae6/xmlnote/A0979183DA124F629EAFC9605981D365/25672" alt=""></p><p>针对递归子目录的监听</p><p><code>ls -R -w /path ： -R 区分大小写，一定用大写</code></p><p>如下对/test 节点进行递归监听，但是每个目录下的目录监听也是一次性的，如第一次在/test 目录下创建节点时，触发监听事件，第二次则没有，同样，因为时递归的目录监听，所以在/test/sub0下进行节点创建时，触发事件，但是再次创建/test/sub0/subsub1节点时，没有触发事件。</p><p><img src="https://note.youdao.com/yws/public/resource/16ab5da92ee89d93f948dc57762b7ae6/xmlnote/080872C676D8462F99E22D2AC9C3631C/25681" alt=""></p><p>Zookeeper事件类型：</p><p>​ None: 连接建立事件</p><p>​ NodeCreated： 节点创建</p><p>​ NodeDeleted： 节点删除</p><p>​ NodeDataChanged：节点数据变化</p><p>​ NodeChildrenChanged：子节点列表变化</p><p>​ DataWatchRemoved：节点监听被移除</p><p>​ ChildWatchRemoved：子节点监听被移除</p><h1 id="zookeeper-的-acl-权限控制-access-control-list" tabindex="-1"><a class="header-anchor" href="#zookeeper-的-acl-权限控制-access-control-list" aria-hidden="true">#</a> <strong>Zookeeper 的 ACL 权限控制( Access Control List )</strong></h1><p>Zookeeper 的ACL 权限控制,可以控制节点的读写操作,保证数据的安全性，Zookeeper ACL 权限设置分为 3 部分组成，分别是：<strong>权限模式</strong>（Scheme）、<strong>授权对象</strong>（ID）、<strong>权限信息</strong>（Permission）。最终组成一条例如“scheme🆔permission”格式的 ACL 请求信息。下面我们具体看一下这 3 部分代表什么意思：</p><p><strong>Scheme（权限模式）</strong>：用来设置 ZooKeeper 服务器进行权限验证的方式。ZooKeeper 的权限验证方式大体分为两种类型：</p><p>一种是<strong>范围验证</strong>。所谓的范围验证就是说 ZooKeeper 可以针对一个 IP 或者一段 IP 地址授予某种权限。比如我们可以让一个 IP 地址为“ip：192.168.0.110”的机器对服务器上的某个数据节点具有写入的权限。或者也可以通过“ip:192.168.0.1/24”给一段 IP 地址的机器赋权。</p><p>另一种权限模式就是<strong>口令验证</strong>，也可以理解为用户名密码的方式。在 ZooKeeper 中这种验证方式是 Digest 认证，而 Digest 这种认证方式首先在客户端传送“username:password”这种形式的权限表示符后，ZooKeeper 服务端会对密码 部分使用 SHA-1 和 BASE64 算法进行加密，以保证安全性。</p><p>还有一种Super权限模式, Super可以认为是一种特殊的 Digest 认证。具有 Super 权限的客户端可以对 ZooKeeper 上的任意数据节点进行任意操作。</p><p><strong>授权对象（ID）</strong></p><p>授权对象就是说我们要把权限赋予谁，而对应于 4 种不同的权限模式来说，如果我们选择采用 IP 方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest 或 Super 方式，则对应于一个用户名。如果是 World 模式，是授权系统中所有的用户。</p><p><strong>权限信息（Permission）</strong></p><p>权限就是指我们可以在数据节点上执行的操作种类，如下所示：在 ZooKeeper 中已经定义好的权限有 5 种：</p><p>数据节点（c: create）创建权限，授予权限的对象可以在数据节点下创建子节点；</p><p>数据节点（w: wirte）更新权限，授予权限的对象可以更新该数据节点；</p><p>数据节点（r: read）读取权限，授予权限的对象可以读取该节点的内容以及子节点的列表信息；</p><p>数据节点（d: delete）删除权限，授予权限的对象可以删除该数据节点的子节点；</p><p>数据节点（a: admin）管理者权限，授予权限的对象可以对该数据节点体进行 ACL 权限设置。</p><p><strong>命令</strong>：</p><p>getAcl：获取某个节点的acl权限信息</p><p>setAcl：设置某个节点的acl权限信息</p><p>addauth: 输入认证授权信息，相当于注册用户信息，注册时输入明文密码，zk将以密文的形式存储</p><p>可以通过系统参数zookeeper.skipACL=yes进行配置，默认是no,可以配置为true, 则配置过的ACL将不再进行权限检测</p><p>addauth digest userName:password # 需要先添加一个用户</p><p>setAcl /testDir/testAcl auth:user1:123456:crwa # 然后才可以拿着这个用户去设置权限</p><p><img src="https://pic2.zhimg.com/80/v2-a64126bd50958c7209e74bb71e132559_720w.png" alt=""></p><h1 id="zookeeper安装" tabindex="-1"><a class="header-anchor" href="#zookeeper安装" aria-hidden="true">#</a> <strong>Zookeeper安装</strong></h1><p>下载地址：https://zookeeper.apache.org/releases.html</p><p><strong>修改配置文件</strong></p><p>解压安装包后进入conf目录，复制zoo_sample.cfg，修改为zoo.cfg</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> cp zoo_sample.cfg  zoo.cfg     
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ <img src="https://note.youdao.com/yws/public/resource/f0549278905bb988c831d6910c54143a/xmlnote/C111F3351AB04CFEA0FE1D9AA99A0BA5/44894" alt=""></p><p><strong>启动zookeeper server</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # 可以通过 bin/zkServer.sh  来查看都支持哪些参数  
 # 默认加载配置路径conf/zoo.cfg 
 bin/zkServer.sh start conf/zoo.cfg 
 # 查看zookeeper状态 bin/zkServer.sh status     
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​</p><p><strong>3）启动zookeeper client连接Zookeeper server</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>bin/zkCli.sh 

# 连接远程的zookeeper s
erver bin/zkCli.sh -server ip:port    
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h1><p><strong>常见cli命令</strong></p><p>https://zookeeper.apache.org/doc/r3.8.0/zookeeperCLI.html</p><table><thead><tr><th>命令基本语法</th><th>功能描述</th></tr></thead><tbody><tr><td>help</td><td>显示所有操作命令</td></tr><tr><td>ls [-s] [-w] [-R] path</td><td>使用 ls 命令来查看当前 znode 的子节点 [可监听] -w: 监听子节点变化 -s: 节点状态信息（时间戳、版本号、数据大小等）-R: 表示递归的获取</td></tr><tr><td>create [-s] [-e] [-c] [-t ttl] path [data] [acl]</td><td>创建节点-s : 创建有序节点。-e : 创建临时节点。-c : 创建一个容器节点。t ttl] : 创建一个TTL节点， -t 时间（单位毫秒）。data：节点的数据，可选，如果不使用时，节点数据就为null。acl：访问控制</td></tr><tr><td>get [-s] [-w] path</td><td>获取节点数据信息 -s: 节点状态信息（时间戳、版本号、数据大小等） -w: 监听节点变化</td></tr><tr><td>set [-s] [-v version] path data</td><td>设置节点数据-s:表示节点为顺序节点-v: 指定版本号</td></tr><tr><td>getAcl [-s] path</td><td>获取节点的访问控制信息-s: 节点状态信息（时间戳、版本号、数据大小等）</td></tr><tr><td>setAcl [-s] [-v version] [-R] path acl</td><td>设置节点的访问控制列表-s:节点状态信息（时间戳、版本号、数据大小等）-v:指定版本号-R:递归的设置</td></tr><tr><td>stat [-w] path</td><td>查看节点状态信息</td></tr><tr><td>delete [-v version] path</td><td>删除某一节点，只能删除无子节点的节点。-v： 表示节点版本号</td></tr><tr><td>deleteall path</td><td>递归的删除某一节点及其子节点</td></tr><tr><td>setquota -n|-b val path</td><td>对节点增加限制n:表示子节点的最大个数b:数据值的最大长度，-1表示无限制</td></tr></tbody></table><p>​</p><h1 id="zookeeper集群" tabindex="-1"><a class="header-anchor" href="#zookeeper集群" aria-hidden="true">#</a> <strong>Zookeeper集群</strong></h1><p>为了保证高可用，最好是以集群来部署 ZooKeeper。通常 3 台服务器就可以构成一个 ZooKeeper 集群了。ZooKeeper 官方提供的架构图就是一个 ZooKeeper 集群整体对外提供服务。</p><p><img src="https://javaguide.cn/assets/zookeeper集群.6fdcc61e.png" alt=""></p><p>上图中每一个 Server 代表一个安装 ZooKeeper 服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 ZAB 协议（ZooKeeper Atomic Broadcast）来保持数据的一致性。</p><p><strong>最典型集群模式： Master/Slave 模式（主备模式）</strong>。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。</p><h2 id="集群角色-1" tabindex="-1"><a class="header-anchor" href="#集群角色-1" aria-hidden="true">#</a> <strong>集群角色</strong></h2><ul><li>Leader： 领导者。</li></ul><p>事务请求（写操作）的唯一调度者和处理者，保证集群事务处理的顺序性；集群内部各个服务器的调度者。对于create、setData、delete等有写操作的请求，则要统一转发给leader处理，leader需要决定编号、执行操作，这个过程称为事务。</p><ul><li>Follower: 跟随者</li></ul><p>处理客户端非事务（读操作）请求（可以直接响应），转发事务请求给Leader；参与集群Leader选举投票。</p><ul><li>Observer: 观察者</li></ul><p>对于非事务请求可以独立处理（读操作），对于事务性请求会转发给leader处理。Observer节点接收来自leader的inform信息，更新自己的本地存储，不参与提交和选举投票。通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</p><p>Observer应用场景：</p><ul><li>提升集群的读性能。因为Observer和不参与提交和选举的投票过程，所以可以通过往集群里面添加observer节点来提高整个集群的读性能。</li><li>跨数据中心部署。 比如需要部署一个北京和香港两地都可以使用的zookeeper集群服务，并且要求北京和香港客户的读请求延迟都很低。解决方案就是把香港的节点都设置为observer。</li></ul><p>leader节点可以处理读写请求，follower只可以处理读请求。follower在接到写请求时会把写请求转发给leader来处理。</p><p><img src="https://pic1.zhimg.com/80/v2-701dd8d4595b5f405a3e88c6f002c5ee_1440w.png" alt=""></p><p>ZooKeeper 集群中的所有机器通过一个 <strong>Leader 选举过程</strong> 来选定一台称为 “<strong>Leader</strong>” 的机器，Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，<strong>Follower</strong> 和 <strong>Observer</strong> 都只能提供读服务。Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>Leader</td><td>为客户端提供读和写的服务，负责投票的发起和决议，更新系统状态。</td></tr><tr><td>Follower</td><td>为客户端提供读服务，如果是写服务则转发给 Leader。参与选举过程中的投票。</td></tr><tr><td>Observer</td><td>为客户端提供读服务，如果是写服务则转发给 Leader。不参与选举过程中的投票，也不参与“过半写成功”策略。在不影响写性能的情况下提升集群的读性能。此角色于 ZooKeeper3.3 系列新增的角色。</td></tr></tbody></table><p>当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，就会进入 Leader 选举过程，这个过程会选举产生新的 Leader 服务器。</p><h2 id="zookeeper-leader-选举原理" tabindex="-1"><a class="header-anchor" href="#zookeeper-leader-选举原理" aria-hidden="true">#</a> <strong>Zookeeper Leader 选举原理</strong></h2><p>zookeeper 的 leader 选举存在两个阶段，一个是服务器启动时 leader 选举，另一个是运行过程中 leader 服务器宕机。</p><p>在分析选举原理前，先介绍几个重要的参数：</p><ul><li>服务器 ID(myid)：编号越大在选举算法中权重越大</li><li>事务 ID(zxid)：值越大说明数据越新，权重越大</li><li>逻辑时钟(epoch-logicalclock)：同一轮投票过程中的逻辑时钟值是相同的，每投完一次值会增加</li></ul><p>选举状态：</p><ul><li>LOOKING: 竞选状态</li><li>FOLLOWING: 随从状态，同步 leader 状态，参与投票</li><li>OBSERVING: 观察状态，同步 leader 状态，不参与投票</li><li>LEADING: 领导者状态</li></ul><p><strong>服务器启动时的 leader 选举</strong></p><p>每个节点启动的时候都 LOOKING 观望状态，接下来就开始进行选举主流程。这里选取三台机器组成的集群为例。第一台服务器 server1启动时，无法进行 leader 选举，当第二台服务器 server2 启动时，两台机器可以相互通信，进入 leader 选举过程。</p><ul><li><p>（1）每台 server 发出一个投票，由于是初始情况，server1 和 server2 都将自己作为 leader 服务器进行投票，每次投票包含所推举的服务器myid、zxid、epoch，使用（myid，zxid）表示，此时 server1 投票为（1,0），server2 投票为（2,0），然后将各自投票发送给集群中其他机器。</p></li><li><p>（2）接收来自各个服务器的投票。集群中的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票（epoch）、是否来自 LOOKING 状态的服务器。</p></li><li><p>（3）分别处理投票。针对每一次投票，服务器都需要将其他服务器的投票和自己的投票进行对比，对比规则如下：</p></li><li><ul><li>a. 优先比较 epoch</li><li>b. 检查 zxid，zxid 比较大的服务器优先作为 leader</li><li>c. 如果 zxid 相同，那么就比较 myid，myid 较大的服务器作为 leader 服务器</li></ul></li><li><p>（4）统计投票。每次投票后，服务器统计投票信息，判断是都有过半机器接收到相同的投票信息。server1、server2 都统计出集群中有两台机器接受了（2,0）的投票信息，此时已经选出了 server2 为 leader 节点。</p></li><li><p>（5）改变服务器状态。一旦确定了 leader，每个服务器响应更新自己的状态，如果是 follower，那么就变更为 FOLLOWING，如果是 Leader，变更为 LEADING。此时 server3继续启动，直接加入变更自己为 FOLLOWING。</p></li></ul><p><img src="https://note.youdao.com/yws/public/resource/f0549278905bb988c831d6910c54143a/xmlnote/C1C52BC4F168430AA227C3AEF05CC842/45570" alt=""></p><p><strong>运行过程中的 leader 选举</strong></p><p>当集群中 leader 服务器出现宕机或者不可用情况时，整个集群无法对外提供服务，进入新一轮的 leader 选举。</p><ul><li>（1）变更状态。leader 挂后，其他非 Oberver服务器将自身服务器状态变更为 LOOKING。</li><li>（2）每个 server 发出一个投票。在运行期间，每个服务器上 zxid 可能不同。</li><li>（3）处理投票。规则同启动过程。</li><li>（4）统计投票。与启动过程相同。</li><li>（5）改变服务器状态。与启动过程相同。</li></ul><p>总结选举过程：</p><ol><li><strong>Leader election（选举阶段）</strong>：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。</li><li><strong>Discovery（发现阶段）</strong> ：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。</li><li><strong>Synchronization（同步阶段）</strong> :同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后 准 leader 才会成为真正的 leader。</li><li><strong>Broadcast（广播阶段）</strong> :到了这个阶段，ZooKeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。</li></ol><h2 id="集群中的服务器状态" tabindex="-1"><a class="header-anchor" href="#集群中的服务器状态" aria-hidden="true">#</a> 集群中的服务器状态</h2><ul><li><strong>LOOKING</strong> ：寻找 Leader。</li><li><strong>LEADING</strong> ：Leader 状态，对应的节点为 Leader。</li><li><strong>FOLLOWING</strong> ：Follower 状态，对应的节点为 Follower。</li><li><strong>OBSERVING</strong> ：Observer 状态，对应节点为 Observer，该节点不参与 Leader 选举。</li></ul><h2 id="选举的过半机制防止脑裂" tabindex="-1"><a class="header-anchor" href="#选举的过半机制防止脑裂" aria-hidden="true">#</a> 选举的过半机制防止脑裂</h2><p><strong>什么是集群脑裂？</strong></p><p>对于一个集群，通常多台机器会部署在不同机房，来提高这个集群的可用性。保证可用性的同时，会发生一种机房间网络线路故障，导致机房间网络不通，而集群被割裂成几个小集群。这时候子集群各自选主导致“脑裂”的情况。</p><p>举例说明：比如现在有一个由 6 台服务器所组成的一个集群，部署在了 2 个机房，每个机房 3 台。正常情况下只有 1 个 leader，但是当两个机房中间网络断开的时候，每个机房的 3 台服务器都会认为另一个机房的 3 台服务器下线，而选出自己的 leader 并对外提供服务。若没有过半机制，当网络恢复的时候会发现有 2 个 leader。仿佛是 1 个大脑（leader）分散成了 2 个大脑，这就发生了脑裂现象。脑裂期间 2 个大脑都可能对外提供了服务，这将会带来数据一致性等问题。</p><p><strong>过半机制是如何防止脑裂现象产生的？</strong></p><p>ZooKeeper 的过半机制导致不可能产生 2 个 leader，因为少于等于一半是不可能产生 leader 的，这就使得不论机房的机器如何分配都不可能发生脑裂。</p><h1 id="zookeeper-数据同步流程" tabindex="-1"><a class="header-anchor" href="#zookeeper-数据同步流程" aria-hidden="true">#</a> <strong>Zookeeper 数据同步流程</strong></h1><p>Zookeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性。</p><p>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p><p>ZAB 协议分为两部分：</p><ul><li>消息广播</li><li>崩溃恢复</li></ul><p><strong>消息广播</strong></p><p>Zookeeper 使用单一的主进程 Leader 来接收和处理客户端所有事务请求，并采用 ZAB 协议的原子广播协议，将事务请求以 Proposal 提议广播到所有 Follower 节点，当集群中有过半的Follower 服务器进行正确的 ACK 反馈，那么Leader就会再次向所有的 Follower 服务器发送commit 消息，将此次提案进行提交。这个过程可以简称为 2pc 事务提交，整个流程可以参考下图，注意 Observer 节点只负责同步 Leader 数据，不参与 2PC 数据同步过程。</p><p>​ <img src="https://note.youdao.com/yws/public/resource/f0549278905bb988c831d6910c54143a/xmlnote/75C0C12CE3AB4E729F408C2AFE869C3A/45559" alt=""></p><p><strong>崩溃恢复</strong></p><p>在正常情况消息下广播能运行良好，但是一旦 Leader 服务器出现崩溃，或者由于网络原理导致 Leader 服务器失去了与过半 Follower 的通信，那么就会进入崩溃恢复模式，需要选举出一个新的 Leader 服务器。在这个过程中可能会出现两种数据不一致性的隐患，需要 ZAB 协议的特性进行避免。</p><ul><li>Leader 服务器将消息 commit 发出后，立即崩溃</li><li>Leader 服务器刚提出 proposal 后，立即崩溃</li></ul><p>ZAB 协议的恢复模式使用了以下策略：</p><ul><li>选举 zxid 最大的节点作为新的 leader</li><li>新 leader 将事务日志中尚未提交的消息进行处理</li></ul><h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h1><ol><li>ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。</li><li>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。</li><li>ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持 znode 中存储的数据量较小的进一步原因）。</li><li>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地明显，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</li><li>ZooKeeper 有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个 znode 被创建了，除非主动进行 znode 的移除操作，否则这个 znode 将一直保存在 ZooKeeper 上。</li><li><strong>创建节点时，必须要带上全路径</strong>，<strong>delete 命令只能一层一层删除。</strong></li></ol></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: zysspace@163.com">javacode</span><!--]--><!--]--></div></div></footer><!----><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!--]--><!----><!--]--></div>
    <script type="module" src="/docs/assets/app-36fed76c.js" defer></script>
  </body>
</html>
