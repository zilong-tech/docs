---
title: 动态修改注解值
author: 程序员子龙
index: true
icon: discover
category:
- Java 基础

---
有的场景需要动态修改注解中的属性值。 可以使用反射或者是spring EL 表达式。

定义注解

```java
@Documented
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface FieldInfo {
    int order();

    int size() default -1;
 }
```

### 反射

动态修改data字段上FieldInfo注解中的size属性值。利用Java的“反射”实现在程序中根据业务进行动态的修改。

```java
Field sample = UploadImageRequest.class.getDeclaredField("data");
MagicField annotation = sample.getAnnotation(FieldInfo.class);
InvocationHandler handler = Proxy.getInvocationHandler(annotation);
Field field = handler.getClass().getDeclaredField("memberValues");
field.setAccessible(true);
Map map = (Map) field.get(handler);
//报文长度
int packetLength = in.getUnsignedShortLE(2);
map.put("size",10);
```

这样size属性值就修改了。

### spring EL



```
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
@Documented
public @interface RedisLock {
    String value();

    String param() default "";

    long waitTime() default 30L;

    long leaseTime() default 100L;

    TimeUnit timeUnit() default TimeUnit.SECONDS;

    LockType type() default LockType.FAIR;
}
```



```java
@RedisLock(value = "key",param = "#query.id",leaseTime = 30L)
public Vo update(Query query) {
}
```



```java
@Around("@annotation(redisLock)")
public Object aroundRedisLock(ProceedingJoinPoint point, RedisLock redisLock) {
    String lockName = redisLock.value();
    Assert.hasText(lockName, "@RedisLock value must have length; it must not be null or empty");
    String lockParam = redisLock.param();
    String lockKey;
    if (StringUtil.isNotBlank(lockParam)) {
        String evalAsText = this.evalLockParam(point, lockParam);
        lockKey = lockName + ':' + evalAsText;
    } else {
        lockKey = lockName;
    }
}

private static final BladeExpressionEvaluator EVALUATOR = new BladeExpressionEvaluator();


private String evalLockParam(ProceedingJoinPoint point, String lockParam) {
    MethodSignature ms = (MethodSignature)point.getSignature();
    Method method = ms.getMethod();
    Object[] args = point.getArgs();
    Object target = point.getTarget();
    Class<?> targetClass = target.getClass();
    EvaluationContext context = EVALUATOR.createContext(method, args, target, targetClass, this.applicationContext);
    AnnotatedElementKey elementKey = new AnnotatedElementKey(method, targetClass);
    return EVALUATOR.evalAsText(lockParam, elementKey, context);
}

  @Nullable
    public String evalAsText(String expression, AnnotatedElementKey methodKey, EvaluationContext evalContext) {
        return (String)this.eval(expression, methodKey, evalContext, String.class);
    }

    @Nullable
    public <T> T eval(String expression, AnnotatedElementKey methodKey, EvaluationContext evalContext, @Nullable Class<T> valueType) {
        return this.getExpression(this.expressionCache, methodKey, expression).getValue(evalContext, valueType);
    }


```

