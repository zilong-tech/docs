---
title: 非静态变量给静态变量赋值
author: 程序员子龙
index: true
icon: discover
category:
- Spring
---
@Value注解介绍：
作为Spring的一个常用注解，其作用是通过注解将常量、配置文件中的值和其他bean的属性值注入到变量中，作为变量的初始值。

```java
@Value("${login.name}")
private String loginName;

```

@value不能直接注入值给静态变量

```
@Value("${login.name}")
private static String loginName;
```

在Java中，静态变量也称为类变量。也就是说，它们属于一个类，而不是一个特定的实例。因此，类初始化的时候也将初始化静态变量相反，类的实例 初始化的时候也将初始化 实例变量(非静态变量)。类的所有实例共享该类的静态变量。

@value 是在 bean实例化后，在属性填充过程中进行赋值的，static初始化要早于@value。

实际场景中，常量需要通过配置文件来配置，该怎么办？

第一种方式：

把@Value(value="${local.file.temp.dir}")放到静态变量的set方法上面即可，需要注意的是set方法要去掉static，还有就是当前类要交给spring来管理

```java
    /**文件存储目录*/
    public static String SAVE_PATH;

    //记得去掉static
    @Value("${local.file.temp.dir}")
    public void setSavePath(String savePath){
        SAVE_PATH = savePath;
    }


```

配置文件：

```yaml
local:
  file:
    temp:
      dir : /data/temp
```

第二种方式:

使用 @postconstruct

```java
    /**文件存储目录*/
    public static String SAVE_PATH;

    @Value("${local.file.temp.dir}")
    public String SAVE_PATH_TEMP;

    @PostConstruct
    private void init(){
        SAVE_PATH = SAVE_PATH_TEMP;
    }

  @GetMapping("test")
    public void test(){

        System.out.println(SAVE_PATH);
    }

```

@PostConstruct 是在 bean 初始化（initializeBean）过程中调用的，是在@value之后调用的，可以通过这种方式给静态变量赋值。

第三种方式：

实现InitializingBean 接口

```java
public class IndexController implements InitializingBean {

    /**文件存储目录*/
    public static String SAVE_PATH;

    @Value("${local.file.temp.dir}")
    public String SAVE_PATH_TEMP;

    @GetMapping("test")
    public void test(){

        System.out.println(SAVE_PATH);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        SAVE_PATH = SAVE_PATH_TEMP;
    }
}

```

InitializingBean 接口也是在bean初始化（initializeBean）过程中调用的，具体可以看下spring bean 的实例化过程。

使用 @value 注解读取配置文件给静态变量赋值的方法给大家介绍到这里，希望对大家有所帮助。
