---
title: 模板设计模式
author: 程序员子龙
index: true
icon: discover
category:
- 设计模式
---
# 模板设计模式

模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供具体实现。

模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。

模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑。模板方法模式的静态结构图如下所示：

![](https://pic2.zhimg.com/80/v2-5fe8cf582a8130c11c6781ea1e76185b_1440w.png)

这里涉及到两个角色：

抽象模板(Abstract Template)角色有如下责任：

- 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。
- 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。

具体模板(Concrete Template)角色有如下责任：

- 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。
- 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。

### 代码实现

定义父类

```java
public abstract class AbstractTemplate {
    /**
     * 模板方法
     */
    public void templateMethod(){
        //调用基本方法
        abstractMethod();
 
        concreteMethod();
    }
    /**
     * 基本方法的声明（由子类实现）
     */
    protected abstract void abstractMethod();
 
    /**
     * 基本方法（已经实现）
     */
    private  void concreteMethod(){
        //业务相关的代码
    }
}

```

具体模板方法

```Java
public class ConcreteTemplate extends AbstractTemplate{
    //基本方法的实现
    @Override
    public void abstractMethod() {
        //业务相关的代码
    }
 
}
```

测试

```Java
public class TemplateMethodTest { 

 public static void main(String[] args) { 

    AbstractTemplate abstractClass = new ConcreteTemplate(); 

     abstractClass.templateMethod(); 

 } 

} 
```

模板模式的关键是：**子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。**

### 应用场景 

1.当你想让客户端只扩展算法的特定步骤，而不是整个算法或其结构时，请使用Template Method模式。 

2.当你有几个类包含几乎相同的算法，但有一些细微的差异时，请使用此模式。 

优点： 

你可以让客户端只覆盖大型算法的某些部分，从而减少算法其他部分发生的更改对它们的影响。