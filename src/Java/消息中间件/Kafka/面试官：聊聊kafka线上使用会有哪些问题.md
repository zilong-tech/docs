---
title: 面试官：聊聊kafka线上使用会有哪些问题
author: 程序员子龙
index: true
icon: discover
category:
- Kafka
---


#### 1、哪些环节会造成消息丢失？

![](https://pic2.zhimg.com/80/v2-504ad1272450a0cd1aafc65c53338441_720w.png)

首先说说哪些环节会丢消息

- **消息生产者：**

（1）acks=0： 表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。性能最高，但是最容易丢消 息。大数据统计报表场景，对性能要求很高，对数据丢失不敏感的情况可以用这种。 

（2）acks=1： 至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送下一条消 息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。 

（3）acks=-1或all： 这意味着leader需要等待所有备份(min.insync.replicas配置的备份个数)都成功写入日志，这种策略会保证只要有一 个备份存活就不会丢失数据。这是最强的数据保证。一般除非是金融级别，或跟钱打交道的场景才会使用这种配置。当然如果 min.insync.replicas配置的是1则也可能丢消息，跟acks=1情况类似。



- **消息消费端**： 

如果消费这边配置的是自动提交，万一消费到数据还没处理完，就自动提交offset了，但是此时你consumer直接宕机了，未处理完的数据 丢失了，下次也消费不到了。 

**怎么保证消息不丢失？**

![](https://server.xmyeditor.com/picture/3/60ac616b3e2a00b02469ed5f085f43fa.jpg)

生产端：消息发送+回调

伪代码

![](https://pica.zhimg.com/80/v2-373212df0e5ef57d66354b85afacccad_720w.png)

消费端：业务处理完后手动提交事务

**2、消息重复消费** 

**消息发送端**： 

发送消息如果配置了重试机制，比如网络抖动时间过长导致发送端发送超时，实际broker可能已经接收到消息，但发送方会重新发送消息 

**消息消费端**： 

如果消费这边配置的是自动提交，刚拉取了一批数据处理了一部分，但还没来得及提交，服务挂了，下次重启又会拉取相同的一批数据重 复处理 

一般消费端都是要做**消费幂等**处理的。 

**3、消息顺序** 

如果发送端配置了重试机制，kafka不会等之前那条消息完全发送成功才去发送下一条消息，这样可能会出现，发送了1，2，3条消息，第 一条超时了，后面两条发送成功，再重试发送第1条消息，这时消息在broker端的顺序就是2，3，1了 所以，是否一定要配置重试要根据业务情况而定。也可以用同步发送的模式去发消息，当然acks不能设置为0，这样也能保证消息从发送 端到消费端全链路有序。 

kafka保证全链路消息顺序消费，需要从发送端开始，将所有有序消息发送到同一个分区，然后用一个消费者去消费，但是这种性能比较 低，可以在消费者端接收到消息后将需要保证顺序消费的几条消费发到内存队列(可以搞多个)，一个内存队列开启一个线程顺序处理消 息。

**4、消息积压** 

1）线上有时因为发送方发送消息速度过快，或者消费方处理消息过慢，可能会导致broker积压大量未消费消息。 此种情况如果积压了上百万未消费消息需要紧急处理，可以修改消费端程序，让其将收到的消息快速转发到其他topic(可以设置很多分 区)，然后再启动多个消费者同时消费新主题的不同分区。 

2）由于消息数据格式变动或消费者程序有bug，导致消费者一直消费不成功，也可能导致broker积压大量未消费消息。 此种情况可以将这些消费不成功的消息转发到其它队列里去(类似**死信队列**)，后面再慢慢分析死信队列里的消息处理问题。 

**5、kafka高性能原因：**

- 磁盘顺序读写：kafka消息不能修改以及不会从文件中间删除保证了磁盘顺序读，kafka的消息写入文件都是追加在文件末尾， 不会写入文件中的某个位置(随机写)保证了磁盘顺序写。 

- 数据传输的零拷贝 

- 读写数据的批量batch处理以及压缩传输 

  

![](https://pic3.zhimg.com/80/v2-3f231e192d8df65a870fc4e5c6c01b7c_720w.png)

传统文件复制方式： 需要对文件在内存中进行四次拷贝。

![](https://pic2.zhimg.com/80/v2-2df923abd3d1a6dcba7dbbba165e067c_720w.png)

零拷贝： 有两种方式， mmap和transfile

![](https://pica.zhimg.com/80/v2-0527cb1e104aedc1d0bfaf6828460e6f_720w.png)

Java当中对零拷贝进行了封装， Mmap方式通过MappedByteBuffer对象进行操作，而transfile通过FileChannel来进行操作。

Mmap 适合比较小的文件，通常文件大小不要超过1.5G ~2G 之间。

Transfile没有文件大小限制



在kafka当中，他的index日志文件也是通过mmap的方式来读写的。在其他日志文件当中，并没有使用零拷贝的方式。

kafka使用transfile方式将硬盘数据加载到网卡。