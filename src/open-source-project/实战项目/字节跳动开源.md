---
title: 字节跳动开源项目
author: 程序员子龙
index: true
icon: discover
category:
- 开源项目
---
马上国庆小长假了，出门旅游是大多数人的选择，很多线路很火爆，更是一票难求，今天给大家推荐一个抢票神器12306passby

页面效果是这样的

![](https://pic3.zhimg.com/80/v2-0a0a83de92e0bcaeacd1b5dcb000eb6f_720w.png)

使用12306登录即可，完全免费的，当然了如果付费会员抢到票后，可以直接自动支付的，非付费会员，抢到票后发微信通知，在12306 APP 上支付也可以！

好了，言归正传，今天给大家推荐几款，字节跳动的开源组件

# 一、CloudWeGo

CloudWeGo是一套以 Go 语言为核心、专注于**微服务通信与治理**的中间件集合，具有高性能、可扩展、高可靠的特点。

> **项目地址**：https://github.com/cloudwego

在亿级流量背后，字节跳动基础架构团队开发的技术底座支撑着庞大的微服务生态系统，从 2018 年至今，团队维护的在线微服务数量增长了近 600%，超过 5万。面对这样的规模和增速，提高性能、可扩展性和稳定性成了构建 CloudWeGo 的核心。

CloudWeGo 有多个子项目，以 RPC 框架 Kitex 和网络库 Netpoll 为主。

## 1、**Kitex**

Kitex 是一个 Golang 微服务 RPC 框架，具有**高性能、强可扩展**的特点。

- **高性能**：Kitex 默认集成自研网络库 Netpoll 作为网络传输模块，性能相较使用 go net 有显著优势；除了网络库带来的性能收益，Kitex 对 Thrift 编解码也做了优化，这在之前的性能优化实践文章中有介绍。关于性能数据，可参考 [https://github.com/cloudwego/kitex-benchmark](https://link.zhihu.com/?target=https%3A//github.com/cloudwego/kitex-benchmark)。
- **扩展性**：Kitex 设计上做了模块划分，提供了较多的扩展接口以及默认的扩展实现，使用者也可以根据需要自行定制扩展。Kitex 未耦合 Netpoll，开发者可选择其他网络库扩展使用。
- **消息协议**：RPC 消息协议默认支持 Thrift、Kitex Protobuf、gRPC。Thrift 支持 Buffered 和 Framed 二进制协议；Kitex Protobuf 是 Kitex 自定义的 Protobuf 消息协议，协议格式类似 Thrift；gRPC 是对 gRPC 消息协议的支持，可以与 gRPC 互通。除此之外，使用者也可以扩展自己的消息协议。
- **传输协议**：传输协议封装消息协议进行 RPC 互通，传输协议可以额外透传元信息，用于服务治理，Kitex 支持的传输协议有 TTHeader、HTTP2。TTHeader 可以和 Thrift、Kitex Protobuf 结合使用；HTTP2 目前主要是结合 gRPC 协议使用，后续也会支持 Thrift。
- **多消息类型**：支持 PingPong、Oneway、双向 Streaming。其中 Oneway 目前只对 Thrift 协议支持，双向 Streaming 只对 gRPC 支持，后续会考虑支持 Thrift 的双向 Streaming。
- **服务治理**：支持服务注册/发现、负载均衡、熔断、限流、重试、监控、链路跟踪、日志、诊断等服务治理模块，大部分均已提供默认扩展，使用者可选择集成。
- **代码生成工具**：Kitex 内置代码生成工具，可支持生成 Thrift、Protobuf 以及脚手架代码。

## 2、Netpoll

Netpoll 是字节跳动内部的 Golang 高性能、I/O 非阻塞的网络库，专注于 RPC 场景。

RPC 通常有较重的处理逻辑（业务逻辑、编解码），耗时长，不能像 Redis 一样采用串行处理（必须异步）。而 Go 的标准库 net 设计了 BIO(Blocking I/O) 模式的 API，为了保证异步处理，RPC 框架设计上需要为每个连接都分配一个 goroutine，这在空闲连接较多时，产生大量的空闲 goroutine，增加调度开销。此外，net.Conn 没有提供检查连接活性的 API，很难设计出高效的连接池，池中的失效连接无法及时清理，复用低效。开源社区目前缺少专注于 RPC 方案的 Go 网络库。类似的项目如：evio、gnet 等，均面向 Redis、Haproxy 这样的场景。

因此 Netpoll 应运而生，它借鉴了 evio 和 Netty 的优秀设计，具有出色的性能，更适用于微服务架构。

## 3、Thriftgo

Thriftgo 是 Go 语言实现的 Thrift IDL 解析和代码生成器，支持完善的 Thrift IDL 语法和语义检查，相较 Apache Thrift 官方的 Golang 生成代码，Thriftgo 做了一些问题修复且支持插件机制，用户可根据需求自定义生成代码。

Kitex 的代码生成工具就是 Thriftgo 的插件，CloudWeGo 近期也会开源另一个 Thriftgo 的插件 thrift-gen-validator，支持 IDL Validator，用于字段值校验，解决开发者需要自行实现代码校验逻辑的负担，弥补 Thrift 缺失的能力。

# 二、IconPark -高质量开源图标库

这是字节跳动公司内部产品体系使用的官方图标库，可以免费商用了。

官方介绍：

> conPark图标库是一个通过技术驱动矢量图标样式的开源图标库，可以实现根据单一SVG源文件变换出多种主题， 具备丰富的分类、更轻量的代码和更灵活的使用场景；致力于构建高质量、统一化、可定义的图标资源，让大多数人都能够选择适合自己的风格图标
>
> 丰富多彩的资源库免费使用、2400+基础图标，29种图标分类，提供更多的选择



![](https://pic1.zhimg.com/80/v2-ee4f8c543e64b951ef4b0cbebaf0282b_720w.png)

### 优势

#### 1、高质量

提供超2000+高质量图标，免费使用，此处给我们勤劳的设计师们点赞~o(￣▽￣)ｄ

#### 2、多主题

根据单一SVG源文件变换多主题，包括：线框、填充、双色、多色，无需使用4种风格的SVG文件

#### 3、跨平台导出组件代码，打通Design to Code

针对技术同学，可导出不同代码库，满足React/Vue/SVG/m移动端/小程序等多种开发场景使用

| React Icons | [React component](https://github.com/bytedance/IconPark/blob/master/packages/react/README.md) | [@icon-pa](https://www.npmjs.com/package/@icon-park/react) [rk/react](https://www.npmjs.com/package/@icon-park/react) |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Vue Icons   | [Vue component](https://github.com/bytedance/IconPark/blob/master/packages/vue/README.md) | [@icon-park/vue](https://www.npmjs.com/package/@icon-park/vue) |
| Vue3 Icons  | [Vue3 Icons](https://github.com/bytedance/IconPark/tree/master/packages/vue-next) | [@icon-park/vue-next](https://www.npmjs.com/package/@icon-park/vue-next) |
| SVG Icons   | [Pure SVG string](https://github.com/bytedance/IconPark/blob/master/packages/svg/README.md) | [@icon-park/svg](https://www.npmjs.com/package/@icon-park/svg) |

#### 4、自定义

在线定制图标样式，每一个图标都被绘制在一个48*48的格子里，你可以在线去更改颜色、大小、线框宽度、端点类型、拐点类型等属性

#### 5、 高效率

丰富的可视化交互，方便用户快速操作图标，直接拿去Sketch、PPT 、复制组件代码在React/Vue项目中去使用

- 复制SVG源码

- 复制React图标代码组件

- 复制Vue图标代码组件

- 下载PNG

- 下载SVG

- 复制PNG（到粘贴板)

  ### 官网介绍

  ![](https://pic2.zhimg.com/80/v2-a9f864b04803c3931d37d672f96dab41_720w.png)

  ![](https://pica.zhimg.com/80/v2-8155f44dd05fbfb578e7214d8a76f2f0_720w.png)

### 官网地址

> https://iconpark.oceanengine.com/home

# 三、AlphaPlayer---视频动画特效SDK

AlphaPlayer是直播中台使用的一个视频动画特效SDK，可以通过制作Alpha通道分离的视频素材，再在客户端上通过OpenGL ES重新实现Alpha通道和RGB通道的混合，从而实现在端上播放带透明通道的视频。

这套方案对设计师而言明显降低了特效的制作成本，对于客户端而言有着更可靠的性能和稳定性，且相比cocos2d引擎有着更低的入门门槛和维护成本，为复杂动画的实现提供了一种全新的方式，新的复杂动画开发将会变得更加简单高效。

## 基本原理

AlphaPlayer主要有两个核心部分，一个是MediaPlayer，负责视频每一帧的解码，支持接入方自行实现；另一个是VideoRenderer，负责将解析出来的每一帧画面进行alpha通道混合，再输出到Surface上。View使用的是GLSurfaceView，性能相对TextureView更优，但层级限制在最顶层。

AlphaPlayer内部是通过Render渲染纹理画面的，设计师导出的视频资源会包含两部分内容——透明遮罩画面和原视频画面两部分，然后通过shader进行alpha值的混合，详细可以看 frag.sh和vertex.sh。

![](https://pica.zhimg.com/80/v2-eabe5890e5244feaf7a11edd13c61a09_720w.png)

原素材的画面中左边部分使用RGB通道存储了原透明视频的Alpha值，右边部分使用RGB通道存储了原透明视频的RGB值，然后在端上通过OpenGL重新将每个像素点的Alpha值和RGB值进行组合，重新得到ARGB视频画面，实现透明视频的动画效果。

## 方案对比

目前较常见的动画实现方案有原生动画、帧动画、gif/webp、lottie/SVGA、cocos引擎，对于复杂动画特效的实现做个简单对比

| 方案        | 实现成本                             | 上手成本 | 还原程度           | 接入成本 |
| ----------- | ------------------------------------ | -------- | ------------------ | -------- |
| 原生动画    | 复杂动画实现成本高                   | 低       | 中                 | 低       |
| 帧动画      | 实现成本低，但资源消耗大             | 低       | 中                 | 低       |
| gif/webp    | 实现成本低，但资源消耗大             | 低       | 只支持8位颜色      | 低       |
| Lottie/SVGA | 实现成本低，部分复杂特效不支持       | 低       | 部分复杂特效不支持 | 低       |
| cocos2d引擎 | 实现成本高                           | 高       | 较高               | 较高     |
| AlphaPlayer | 开发无任何实现成本，一次接入永久使用 | 低       | 高                 | 低       |

## 运行效果

![](https://pic3.zhimg.com/80/v2-725009ef65cb33820248f9faca75b674_720w.gif)

## 项目地址

> https://github.com/bytedance/AlphaPlayer

# 四、xgplayer---西瓜播放器

![](https://pica.zhimg.com/80/v2-30bb5408975f285bcb7e51358a7ba872_720w.png)

西瓜播放器是一个Web视频播放器类库，它本着一切都是组件化的原则设计了独立可拆卸的 UI 组件。更重要的是它不只是在 UI 层有灵活的表现，在功能上也做了大胆的尝试：摆脱视频加载、缓冲、格式支持对 video 的依赖。尤其是在 mp4 点播上做了较大的努力，让本不支持流式播放的 mp4 能做到分段加载，这就意味着可以做到清晰度无缝切换、加载控制、节省视频流量。同时，它也集成了对 flv、hls、dash 的点播和直播支持。

![](https://pica.zhimg.com/80/v2-59c63ae0b50cc983d42263118049647d_720w.png)

### 插件

西瓜播放器提供了较多的插件，插件分两类：一部分是自启动的，一部分是继承播放器核心类 xgplayer 的。原则上官方提供插件都是自启动的，封装的第三方类库都是继承方式。有些功能插件本身能提供降级方案建议使用自启动方式，否则建议使用继承方式。播放器支持自定义插件。

### 内置插件

| 插件          | 功能                                                         |
| ------------- | ------------------------------------------------------------ |
| play          | 控制条的播放/暂停按钮，不建议改动。                          |
| time          | 控制条的当前时间/视频时长显示组件，可以自定义。              |
| volume        | 控制条的音量控制组件，不建议改动。                           |
| definition    | 控制条的清晰度切换组件，不建议改动，事件驱动满足任意形式的实现。 |
| fullscreen    | 控制条的全屏切换组件，不建议改动。                           |
| poster        | 播放器贴图，不建议改动。                                     |
| progress      | 播放器进度条和预览图，不建议改动。                           |
| loading       | 播放器加载提示，可以自定义。                                 |
| error         | 播放器错误提示，可以自定义。                                 |
| replay        | 播放器重播操作界面，可以自定义。                             |
| playbackRate  | 播放器倍速播放，不建议改动。                                 |
| makeBullet    | 播放器弹幕，不建议改动。                                     |
| textTrack     | 播放器外挂字幕，不建议改动。                                 |
| pip           | 播放器画中画功能，不建议改动                                 |
| cssFullscreen | 控制条的网页样式全屏切换组件，icon可以自定义。               |
| screenShot    | 播放器内部截图，截图格式可以自定义。                         |
| playNext      | 播放器跳转播放下一集，不建议改动。                           |
| rotate        | 播放器旋转控件，可以自定义。                                 |
| download      | 播放器下载控件，可以自定义。                                 |
| localPreview  | 播放器预览本地视频功能，不建议改动。                         |
| i18n          | 播放器多语种定义，不建议改动，通过配置项增加其他语言。       |
| pc            | 播放器PC交互定义，包括进场动画。                             |
| mobile        | 播放器mobile交互定义，包括进场动画。                         |

### 自定义插件

1. 开发插件

   ![](https://pic2.zhimg.com/80/v2-f4ea83d9be61d2ae6ff95beea41e9000_720w.png)

2. 使用插件

   

![](https://pic2.zhimg.com/80/v2-9dd6862710b367357b2a20ae9ad73a01_720w.png)

### 项目地址

> https://github.com/bytedance/xgplayer
>
> http://v2.h5player.bytedance.com/

# 五、ByteX

ByteX是一个基于gradle transform api和ASM的字节码插件平台。

目前集成了若干个字节码插件，每个插件完全独立，既可以脱离ByteX这个宿主而独立存在，又可以自动集成到宿主和其它插件一起整合为一个单独的Transform。插件和插件之间，宿主和插件之间的代码是完全解耦的（有点像组件化），这使得ByteX在代码上拥有很好的可拓展性，新插件的开发将会变得更加简单高效。

## 背景

如果所有feature都开发一个单独的插件，每个插件编译构建耗时+10s，各个插件叠在一起，编译耗时就会呈线性增长；那如果我们所有feature都基于一个现成的字节码插件做迭代开发，又会让插件代码变得越来越臃肿，代码耦合严重。所以就有了这个想法，单独做一个字节码插件开发平台，新的feature可以基于它做扩展。

## 特点

- 代码复用。公共的代码下沉下到common，给所有插件复用，这样每个插件就只需要专注于字节码插桩就行了。
- 插件间代码隔离，相互解耦。之前字节码的相关feature都是基于某个字节码插件module来迭代扩展的，但各个feature的代码耦合在一起，久而久之这个插件module就成为了大杂烩。而基于ByteX，各个feature都独立成一个个插件，各个feature的代码相互隔离，相互独立，有利于新插件的功能拓展。
- 平台化让transform更高效。
  - class文件多线程并发处理，充分利用打包机的CPU资源。
  - 插件间自动无缝地整合成一个Transform，提高处理构建的效率。Transform过程中，对class文件的IO是比较耗时的，把所有的plugin整合成一个单独transform可以避免打包的额外时间开销呈线性增长。让耗时从1+1=2，变成1+1<2或者约等于1。
- 插件移植性强。每个插件都可以脱离ByteX宿主，独立成一个transform，独立工作。

## 项目结构

![](https://pic1.zhimg.com/80/v2-969497dd6bbdb3639dbfac26bef0c6f0_720w.png)

**TransformEngine**

负责遍历读取工程和Android SDK里的所有class文件，并回写到transform指定目录。

**base-plugin**

宿主，也就一个壳。

**common**

基础代码库，包括类图构建逻辑，日志，提供给各个插件的适配接口等。

**其它插件module**

依赖common，实现相应的接口和各自的字节码插桩逻辑。

## 已集成的插件

- [access-inline-plugin](https://github.com/bytedance/ByteX/blob/master/access-inline-plugin/README-zh.md)（access方法内联）
- [shrink-r-plugin](https://github.com/bytedance/ByteX/blob/master/shrink-r-plugin/README-zh.md)（R文件瘦身和无用资源检查）
- [closeable-check-plugin](https://github.com/bytedance/ByteX/blob/master/closeable-check-plugin/README-zh.md)（文件流的close检查）
- [const-inline-plugin](https://github.com/bytedance/ByteX/blob/master/const-inline-plugin/README-zh.md)（常量内联）
- [field-assign-opt-plugin](https://github.com/bytedance/ByteX/blob/master/field-assign-opt-plugin/README-zh.md)（优化多余赋值指令）
- [getter-setter-inline-plugin](https://github.com/bytedance/ByteX/blob/master/getter-setter-inline-plugin/README-zh.md) （getter和setter方法内联）
- [method-call-opt-plugin](https://github.com/bytedance/ByteX/blob/master/method-call-opt-plugin/README-zh.md)（干净地删除某些方法调用，如`Log.d`）
- [coverage-plugin](https://github.com/bytedance/ByteX/blob/master/coverage/README-zh.md)（线上代码覆盖率）
- [refer-check-plugin](https://github.com/bytedance/ByteX/blob/master/refer-check-plugin/README-zh.md)（检查是否有调用不存在的方法和引用不存在的字段）
- [serialization-check-plugin](https://github.com/bytedance/ByteX/blob/master/serialization-check-plugin/README-zh.md)（序列化检查）
- [SourceFileKiller](https://github.com/bytedance/ByteX/blob/master/SourceFileKiller/README-zh.md)（删除SourceFile和行号属性，作为示例）
- [ButterKnifeChecker](https://github.com/bytedance/ByteX/blob/master/butterknife-check-plugin/README-zh.md)（检测跨module使用ButterKnife可能导致的问题）
- [RFileKnife](https://github.com/bytedance/ByteX/blob/master/shrink-r-plugin/RFileKnife-README-zh.md)（修复R.java太大编译报code too large的问题）

### 项目地址

> https://github.com/bytedance/ByteX