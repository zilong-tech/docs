---
title: 建造者模式
author: 程序员子龙
index: true
icon: discover
category:
- 设计模式
---
### 定义

建造者模式（Builder Pattern）也叫做生成器模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

在建造者模式中，有如下4个角色：
● Product产品类
通常是实现了模板方法模式，也就是有模板方法和基本方法。

● Builder抽象建造者
规范产品的组建，一般是由子类实现。例子中的CarBuilder就属于抽象建造者。

● ConcreteBuilder具体建造者
实现抽象类定义的所有方法，并且返回一个组建好的对象。例子中的BenzBuilder和BMWBuilder就属于具体建造者。

● Director导演类
负责安排已有模块的顺序，然后告诉Builder开始建造。

![image-20211215172203447](https://gitee.com/zysspace/pic/raw/master/images/202112151722173.png)

### 代码实现

1、产品类

```Java
/**
 * 产品类：包含多个组成部件的复杂对象
 * @version 1.0.0
 * @date 2021/12/15 17:28
 */
public class Product {

    private String partA;
    private String partB;
    private String partC;

    public void setPartA(String partA) {
        this.partA = partA;
    }
    public void setPartB(String partB) {
        this.partB = partB;
    }
    public void setPartC(String partC) {
        this.partC = partC;
    }

    public String getPartA() {
        return partA;
    }

    public String getPartB() {
        return partB;
    }

    public String getPartC() {
        return partC;
    }

    public void show() {
        //显示产品的特性
        System.out.println(getPartA() + " " + getPartB() + " " + getPartC());
    }
}

```

2、抽象建造者

```java
/**
 * 抽象建造者：包含创建产品各个子部件的抽象方法。
 * @version 1.0.0
 * @date 2021/12/15 17:30
 */
public abstract class Builder {

    //创建产品对象
    protected Product product = new Product();
    public abstract void buildPartA();
    public abstract void buildPartB();
    public abstract void buildPartC();

    //返回产品对象
    public Product getResult() {
        return product;
    }
}

```

3、导演类

```java
/**
 * @author 导演类:调用建造者中的方法完成复杂对象的创建。
 * @version 1.0.0
 * @date 2021/12/15 17:54
 */
public class Director {

    private Builder builder;
    public Director(Builder builder) {
        this.builder = builder;
    }
    //产品构建与组装方法
    public Product construct() {
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
        return builder.getResult();
    }
}
```

4、具体建造者

```
/**
 * 具体建造者：实现了抽象建造者接口。
 * @version 1.0.0
 * @date 2021/12/15 17:34
 */
public class ConcreteProductBuilder extends Builder{

    @Override
    public void buildPartA() {
        product.setPartA("建造 PartA");
    }
    @Override
    public void buildPartB() {
        product.setPartB("建造 PartB");
    }
    @Override
    public void buildPartC() {
        product.setPartC("建造 PartC");
    }
}
```

5、测试类：

```Java
public class Client {

    public static void main(String[] args) {
        Builder builder = new ConcreteProductBuilder();
        Director director = new Director(builder);
        Product product = director.construct();
        product.show();
    }
}
```

### 建造者模式的优点

● 封装性
使用建造者模式可以使客户端不必知道产品内部组成的细节，如例子中我们就不需要关心每一个具体的模型内部是如何实现的，产生的对象类型就是CarModel。
● 建造者独立，容易扩展
BenzBuilder和BMWBuilder是相互独立的，对系统的扩展非常有利。
● 便于控制细节风险
由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。

### 使用场景

● 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。
● 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。
● 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。
● 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。

### 总结

这个建造者模式和工厂模式非常相似呀，是的，非常相似，但是记住一点你就可以游刃有余地使用了：建造者模式最主要的功能是基本方法的调用顺序安排，也就是这些基本方法已经实现了，通俗地说就是零件的装配，顺序不同产生的对象也不同；而工厂方法则重点是创建，创建零件是它的主要职责，组装顺序则不是它关心的。