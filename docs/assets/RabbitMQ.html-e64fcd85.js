import{_ as p,W as a,X as c,a1 as e}from"./framework-2afc6763.js";const t={},n=e('<h3 id="消息丢失" tabindex="-1"><a class="header-anchor" href="#消息丢失" aria-hidden="true">#</a> 消息丢失</h3><p>发送方确认机制：</p><p>信道需要设置为 confirm 模式，则所有在信道上发布的消息都会分配一个唯一 ID。</p><p>一旦消息被投递到queue（可持久化的消息需要写入磁盘），信道会发送一个确认给生产者（包含消息唯一 ID）。</p><p>如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（未确认）消息给生产者。</p><p>所有被发送的消息都将被 confirm（即 ack） 或者被nack一次。但是没有对消息被 confirm 的快慢做</p><p>任何保证，并且同一条消息不会既被 confirm又被nack 发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者，</p><p>生产者的回调方法会被触发。</p><p>ConfirmCallback接口：只确认是否正确到达 Exchange 中，成功到达则回调</p><p>ReturnCallback接口：消息失败返回时回调</p><p>接收方确认机制：</p><p>消费者在声明队列时，可以指定noAck参数，当noAck=false时，RabbitMQ会等待消费者显式发回ack信号</p><p>后才从内存(或者磁盘，持久化消息)中移去消息。否则，消息被消费后会被立即删除。</p><p>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，</p><p>RabbitMQ 才能安全地把消息从队列中删除。</p><p>RabbitMQ不会为未ack的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该</p><p>消息的消费者连接是否已经断开。这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很长。保</p><p>证数据的最终一致性；</p><p>如果消费者返回ack之前断开了链接，RabbitMQ 会重新分发给下一个订阅的消费者。（可能存在消息重复消</p><p>费的隐患，需要去重）</p>',20),i=[n];function o(r,b){return a(),c("div",null,i)}const _=p(t,[["render",o],["__file","RabbitMQ.html.vue"]]);export{_ as default};
