import{_ as i,W as a,X as t,Y as e,Z as n,a0 as d,a1 as c,F as s}from"./framework-2afc6763.js";const l={},r=c(`<p>MVCC(Mutil-Version Concurrency Control)，就是多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。</p><p>在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。</p><p>这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。</p><p>准备表</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>CREATE TABLE \`user\` (
	\`id\` INT(11) NOT NULL,
	\`name\` VARCHAR(20) NULL DEFAULT NULL
)
ENGINE=InnoDB
;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="innodb-对-mvcc-的实现" tabindex="-1"><a class="header-anchor" href="#innodb-对-mvcc-的实现" aria-hidden="true">#</a> InnoDB 对 MVCC 的实现</h2><p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p><h2 id="隐藏列" tabindex="-1"><a class="header-anchor" href="#隐藏列" aria-hidden="true">#</a> 隐藏列</h2><p><code>InnoDB</code> 存储引擎为每行数据添加了三个隐藏字段</p><p>[]: https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html</p><p><strong>事务ID（DB_TRX_ID）</strong>：表示最后一次插入或更新该行的事务 id。</p><p><strong>回滚指针（DB_ROLL_PTR）</strong>：指向该行的 <code>undo log</code> 。如果该行未被更新，则为空。</p><p><strong>DB_ROW_ID</strong>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</p><p>每开始一个新的事务（新增、修改、删除），都会自动递增产生一个新的事务id。</p><p><img src="https://pic3.zhimg.com/v2-a3c571ad033a90427a2d3f5cae56636e_b.png" alt="img"></p><p>InnoDB的MVCC是通过DATA_TRX_ID和DATA_ROLL_PTR这两个隐藏列来实现的。</p><h2 id="undo-log" tabindex="-1"><a class="header-anchor" href="#undo-log" aria-hidden="true">#</a> <strong>undo log</strong></h2><p><code>undo log</code> 主要有两个作用：</p><ul><li>当事务回滚时用于将数据恢复到修改前的样子</li><li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读。</li></ul><p>根据行为的不同，undo log分为两种：<strong>insert undo log</strong> 和 <strong>update undo log</strong></p><ul><li><strong>insert undo log：</strong></li></ul><p>insert 操作中产生的undo log，因为insert操作记录只对当前事务本身，对于其他事务此记录不可见，所以 insert undo log 可以在事务提交后直接删除而不需要进行purge操作。</p><p>purge的主要任务是将数据库中已经 mark del 的数据删除，另外也会批量回收undo pages</p><p><img src="https://pic3.zhimg.com/v2-9f535b6b71782f54f36c9722e6ab1aae_b.png" alt="img"></p><p><strong>update undo log：</strong></p><p>update 或 delete 操作中产生的 undo log。</p><p><img src="https://pic3.zhimg.com/v2-2be593a116df5e6166a4ecbcc3c6e6ea_b.png" alt="img"></p><h2 id="事务链表" tabindex="-1"><a class="header-anchor" href="#事务链表" aria-hidden="true">#</a> 事务链表</h2><p>MySQL中的事务在开始到提交这段过程中，都会被保存到一个叫trx_sys的事务链表中，这是一个基本的链表结构：</p><h2 id="read-view-快照" tabindex="-1"><a class="header-anchor" href="#read-view-快照" aria-hidden="true">#</a> Read View(快照)</h2><p>在 <code>InnoDB</code> 存储引擎中，创建一个新事务后，执行每个 <code>select</code> 语句前，都会创建一个快照（Read View），<strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>。</p><p><strong>ReadView</strong>中主要包含当前系统中还有哪些活跃的事务（未提交的事务），把它们的事务id放到一个列表中，我们把这个列表命名为为<strong>m_ids</strong>。</p><p>当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code> 会将该记录行的 <code>DB_TRX_ID</code> 与 <code>Read View</code> 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>class ReadView <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
private<span class="token operator">:</span>
  <span class="token class-name">trx_id_t</span> m_low_limit_id<span class="token punctuation">;</span>      <span class="token comment">/* 大于等于这个 ID 的事务均不可见 */</span>

  <span class="token class-name">trx_id_t</span> m_up_limit_id<span class="token punctuation">;</span>       <span class="token comment">/* 小于这个 ID 的事务均可见 */</span>

  <span class="token class-name">trx_id_t</span> m_creator_trx_id<span class="token punctuation">;</span>    <span class="token comment">/* 创建该 Read View 的事务ID */</span>

  <span class="token class-name">trx_id_t</span> m_low_limit_no<span class="token punctuation">;</span>      <span class="token comment">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span>

  <span class="token class-name">ids_t</span> m_ids<span class="token punctuation">;</span>                  <span class="token comment">/* 创建 Read View 时的活跃事务列表 */</span>

  m_closed<span class="token punctuation">;</span>                     <span class="token comment">/* 标记 Read View 是否 close */</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要有以下字段：</p><ul><li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li><li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li><li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li><li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li></ul><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202203041012520.png" alt=""></p><p>对于RR隔离级别，版本链比对规则：</p><ul><li>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该版本可以被当前事务访问。</li><li>如果 DB_TRX_ID &gt;= m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该版本不可以被当前事务访问。</li><li>m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的。</li><li>如果 m_up_limit_id &lt;= DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找 ：如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</li><li>在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code> 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空。</li></ul><p><img src="https://pic1.zhimg.com/v2-a0a3bad1a420def139f85f6fdd521408_b.png" alt="img"></p><p><img src="https://pic4.zhimg.com/v2-0a3d5d1e4163e93542356a2a1c958e7b_b.png" alt="img"></p><h2 id="在-rr-下-readview-生成情况" tabindex="-1"><a class="header-anchor" href="#在-rr-下-readview-生成情况" aria-hidden="true">#</a> 在 RR 下 ReadView 生成情况</h2><p><strong>在可重复读级别下，只会在事务开始后第一次读取数据时生成一个 Read View（m_ids 列表）</strong></p><p>原始数据：</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>菜花</td></tr></tbody></table><p><img src="https://ddmcc-1255635056.file.myqcloud.com/6fb2b9a1-5f14-4dec-a797-e4cf388ed413.png" alt="img"></p><p><strong>1、在 T4 情况下的版本链为：</strong></p><p><img src="https://ddmcc-1255635056.file.myqcloud.com/0e906b95-c916-4f30-beda-9cb3e49746bf.png" alt=""></p><p>在当前执行 <code>select</code> 语句时生成一个 <code>Read View</code>，此时 <strong><code>m_ids</code>：[101,102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code> 为：103 。</p><p>最新记录的 <code>DB_TRX_ID</code> 为 101，m_up_limit_id &lt;= 101 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</p><p>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是 101，不可见</p><p>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 <code>name = 菜花</code></p><p><strong>2、时间点 T6 情况下：</strong></p><p><img src="https://ddmcc-1255635056.file.myqcloud.com/79ed6142-7664-4e0b-9023-cf546586aa39.png" alt=""></p><ol><li>在 RR 级别下只会生成一次<code>Read View</code>，所以此时依然沿用 <strong><code>m_ids</code> ：[101,102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code> 为：103</li></ol><ul><li>最新记录的 <code>DB_TRX_ID</code> 为 102，m_up_limit_id &lt;= 102 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</li><li>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 为 101，不可见</li><li>继续根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是 101，不可见</li><li>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 <code>name = 菜花</code></li></ul><p><strong>3、时间点 T9 情况下：</strong></p><p><img src="https://ddmcc-1255635056.file.myqcloud.com/cbbedbc5-0e3c-4711-aafd-7f3d68a4ed4e.png" alt=""></p><h2 id="rc-和-rr-隔离级别下-mvcc-的差异" tabindex="-1"><a class="header-anchor" href="#rc-和-rr-隔离级别下-mvcc-的差异" aria-hidden="true">#</a> RC 和 RR 隔离级别下 MVCC 的差异</h2><p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p><ul><li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li><li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表）</li></ul><h2 id="mvcc-next-key-lock-防止幻读" tabindex="-1"><a class="header-anchor" href="#mvcc-next-key-lock-防止幻读" aria-hidden="true">#</a> MVCC+Next-key-Lock 防止幻读</h2><p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p><p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p><p><strong>2、执行 select...for update/lock in share mode、insert、update、delete 等当前读</strong></p>`,66),p=e("code",null,"InnoDB",-1),_={href:"https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks",target:"_blank",rel:"noopener noreferrer"},m=c('<h2 id="mvcc总结" tabindex="-1"><a class="header-anchor" href="#mvcc总结" aria-hidden="true">#</a> <strong>MVCC总结</strong></h2><p>所谓的MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用 <strong>READ COMMITTD</strong> 、<strong>REPEATABLE READ</strong> 这两种隔离级别的事务在执行普通的 SEELCT 操作时访问记录的版本链的过程，这样子可以使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。</p><p>在 MySQL 中， READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们生成 ReadView 的时机不同。在 READ COMMITTED 中每次查询都会生成一个实时的 ReadView，做到保证每次提交后的数据是处于当前的可见状态。而 REPEATABLE READ 中，在当前事务第一次查询时生成当前的 ReadView，并且当前的 ReadView 会一直沿用到当前事务提交，以此来保证可重复读（REPEATABLE READ）。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2><p><strong>《MySQL 技术内幕 InnoDB 存储引擎第 2 版》</strong></p>',5),u={href:"https://tech.meituan.com/2014/08/20/innodb-lock.html",target:"_blank",rel:"noopener noreferrer"},g={href:"https://tech.meituan.com/2014/08/20/innodb-lock.html",target:"_blank",rel:"noopener noreferrer"},h={href:"https://tech.meituan.com/2014/08/20/innodb-lock.html",target:"_blank",rel:"noopener noreferrer"},R={href:"https://blog.csdn.net/qq_35190492/article/details/109044141",target:"_blank",rel:"noopener noreferrer"},D={href:"https://blog.csdn.net/qq_35190492/article/details/109044141",target:"_blank",rel:"noopener noreferrer"},b={href:"https://blog.csdn.net/qq_35190492/article/details/109044141",target:"_blank",rel:"noopener noreferrer"},v={href:"https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/",target:"_blank",rel:"noopener noreferrer"},I={href:"https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/",target:"_blank",rel:"noopener noreferrer"};function f(B,C){const o=s("ExternalLinkIcon");return a(),t("div",null,[r,e("p",null,[n("在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！"),p,n(" 使用 "),e("a",_,[n("Next-key Lock"),d(o)])]),m,e("p",null,[e("a",u,[n("Innodb 中的事务隔离级别和锁的关系"),d(o)]),e("a",g,[d(o)]),e("a",h,[n(" (opens new window)"),d(o)])]),e("p",null,[e("a",R,[n("MySQL 事务与 MVCC 如何实现的隔离级别"),d(o)]),e("a",D,[d(o)]),e("a",b,[n(" (opens new window)"),d(o)])]),e("p",null,[e("a",v,[n("InnoDB 事务分析-MVCC"),d(o)]),e("a",I,[d(o)])])])}const T=i(l,[["render",f],["__file","MVCC.html.vue"]]);export{T as default};
