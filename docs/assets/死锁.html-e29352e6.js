import{_ as e,W as a,X as n,a1 as d}from"./framework-2afc6763.js";const i={},c=d('<p>死锁：是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用，它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。表级锁不会产生死锁。</p><p>由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。 一种情形，此时执行程序中两个或多个线程发生永久堵塞（等待），每个线程都在等待被其他线程占用并堵塞了的资源。例如，如果线程A锁住了记录1并等待记录2，而线程B锁住了记录2并等待记录1，这样两个线程就发生了死锁现象。计算机系统中,如果系统的资源分配策略不当，更常见的可能是程序员写的程序有错误等，则会导致进程因竞争资源不当而产生死锁的现象。锁有多种实现方式，比如意向锁，共享－排他锁，锁表，树形协议，时间戳协议等等。锁还有多种粒度，比如可以在表上加锁，也可以在记录上加锁。</p><h3 id="产生死锁的原因" tabindex="-1"><a class="header-anchor" href="#产生死锁的原因" aria-hidden="true">#</a> 产生死锁的原因</h3><p>（1）进程推进顺序不当造成死锁。</p><p>（2）竞争不可抢占性资源引起死锁。</p><p>（3）竞争可消耗性资源引起死锁。</p><h3 id="产生死锁的四个必要条件" tabindex="-1"><a class="header-anchor" href="#产生死锁的四个必要条件" aria-hidden="true">#</a> 产生死锁的四个必要条件</h3><p>（1） 互斥条件：一个资源每次只能被一个进程使用。 （2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 （3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 （4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p><p>准备表：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>CREATE TABLE `account` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) DEFAULT NULL,\n  `balance` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=1\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>事务A：INSERT INTO <code>account</code> VALUES (7, &#39;7&#39;, 7);</p><p>事务B：INSERT INTO <code>account</code> VALUES (9, &#39;9&#39;, 9);</p><p>事务A：INSERT INTO <code>account</code> VALUES (9, &#39;9&#39;, 9);</p><p>事务B：INSERT INTO <code>account</code> VALUES (7, &#39;7&#39;, 7);</p><p>一般的情况，两个session分别通过一个sql持有一把锁，然后互相访问对方加锁的数据产生死锁。</p><p>查看近期死锁日志信息：show engine innodb status\\G;</p><h3 id="死锁的常见表现" tabindex="-1"><a class="header-anchor" href="#死锁的常见表现" aria-hidden="true">#</a> 死锁的常见表现</h3><p>死锁不仅会发生多个进程中，也会发生在一个进程中。 （1）多进程死锁：有进程A，进程B，进程A拥有资源1，需要请求正在被进程B占有的资源2。而进程B拥有资源2，请求正在被进程A战友的资源1。两个进程都在等待对方释放资源后请求该资源，而相互僵持，陷入死锁。</p><p>（2）单进程死锁：进程A拥有资源1，而它又在请求资源1，而它所请求的资源1必须等待该资源使用完毕得到释放后才可被请求。这样，就陷入了自己的死锁。</p><h3 id="如何预防死锁" tabindex="-1"><a class="header-anchor" href="#如何预防死锁" aria-hidden="true">#</a> <strong>如何预防死锁</strong></h3><p>阻止死锁的途径就是避免满足死锁条件的情况发生，为此我们在开发的过程中需要遵循如下原则：</p><p>1.尽量避免并发的执行涉及到修改数据的语句。</p><p>2.要求每一个事务一次就将所有要使用到的数据全部加锁，否则就不允许执行。</p><p>3.预先规定一个加锁顺序，所有的事务都必须按照这个顺序对数据执行封锁。如不同的过程在事务内部对对象的更新执行顺序应尽量保证一致。</p><p>4.每个事务的执行时间不可太长，对程序段的事务可考虑将其分割为几个事务。在事务中不要求输入，应该在事务之前得到输入，然后快速执行事务。</p><p>5.使用尽可能低的隔离级别。</p><p>6.数据存储空间离散法。该方法是指采用各种手段，将逻辑上在一个表中的数据分散的若干离散的空间上去，以便改善对表的访问性能。主要通过将大表按行或者列分解为若干小表，或者按照不同的用户群两种方法实现。</p><p>7.编写应用程序，让进程持有锁的时间尽可能短，这样其它进程就不必花太长的时间等待锁被释放。</p>',29),p=[c];function s(r,t){return a(),n("div",null,p)}const l=e(i,[["render",s],["__file","死锁.html.vue"]]);export{l as default};
