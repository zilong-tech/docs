import{_ as e,W as a,X as s,a1 as p}from"./framework-2afc6763.js";const n={},i=p('<h3 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h3><p>事务是数据库管理系统（DBMS）执行过程中的一个逻辑单位（不可再进行分割），由一个有限的数据库操作序列构成（多个DML语句，select语句不包含事务），要不全部成功，要不全部不成功。</p><h3 id="事务基本特性acid是什么" tabindex="-1"><a class="header-anchor" href="#事务基本特性acid是什么" aria-hidden="true">#</a> 事务基本特性ACID是什么？</h3><p><strong>原子性</strong>（atomicity)</p><p>一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么 全部提交成功，要么全部失败，对于一个事务来说，不能只执行其中的一部分操作。</p><p>undo log 是InnoDB存储引擎特有的。具体的实现方式是：将所有对数据的修改（增、删、改）都写入日志（undo log）。如果一个事务中的一部分操作已经成功，但另一部分操作，由于断电/系统崩溃/其它的软硬件错误而无法成功执行，则通过回溯日志，将已经执行成功的操作撤销，从而达到全部操作失败的目的。</p><p>undo log是逻辑日志，可以理解为：记录和事务操作相反的SQL语句，事务执行insert语句，undo log就记录delete语句。它以追加写的方式记录日志，不会覆盖之前的日志。除此之外undo log还用来实现数据库多版本并发控制（Multiversion Concurrency Control，简称MVCC）</p><p><strong>一致性</strong>（consistency)</p><p>一致性是指事务将数据库从一种一致性转换到另外一种一致性状态，在事务开始之前和事务结束之后数据库中数据的完整性没有被破坏。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性。</p><p>例如转账：A给B转账，A减去500，B增加500，减少和增加相加应该是0</p><p><strong>隔离性</strong>（Isolation）</p><p>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据 对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。</p><p>如果隔离性不能保证，会导致什么问题？</p><p>张三借给李四生活费，借了两次，每次都是 500，张三的卡里开始有 1200，李四的卡里开始有 300，从理论上，借完后，张三的卡里有 200，李四的卡里应该有 1300。</p><p>我们将 张三向李四同时进行的两次转账操作分别称为 T1 和 T2，在现实世界中 T1 和 T2 是应该没有关系的，可以先执行完 T1，再执行 T2，或者先执行完 T2，再执行 T1，结果都是一样的。但是很不幸，真实的数据库中 T1 和 T2 的操作可能交替执行的，执行顺序就有可能是：</p><img src="https://pic3.zhimg.com/80/v2-a6a75be093be1bf80ac1409fb7e34614_1440w.png" style="zoom:50%;"><p>如果按照上图中的执行顺序来进行两次转账的话，最终我们看到，张三 的账户里还剩 700 元钱，相当于只扣了 500 元钱，但是李四的账户里却成了 1300 元钱，多出现了 500 元，银行是不是亏了！</p><p>所以对于现实世界中状态转换对应的某些数据库操作来说，不仅要保证这些 操作以原子性的方式执行完成，而且要保证其它的状态转换不会影响到本次状态转换，这个规则被称之为隔离性。</p><p>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</p><p><strong>持久性</strong>（Durability）</p><p>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失。MySQL事务的持久性是通过redo log 来实现的。redo log也是InnoDB存储引擎特有的。具体实现方式是：当发生数据修改（增、删、改）的时候，InnoDB引擎会先将记录写到redo log中，并更新内存，此时更新就算完成了。同时InnoDB引擎会在合适的时机将记录刷到磁盘中。</p><p>redo log是物理日志，记录的是在某个数据页做了什么修改，而不是SQL语句的形式。它有固定大小，是循环写的方式记录日志，空间用完后会覆盖之前的日志。</p><p>undo log保证原子性，redo log保证持久性，设置隔离级别，保证并发事务进行的时候，保证数据一致性。</p><h3 id="事务并发引发的问题" tabindex="-1"><a class="header-anchor" href="#事务并发引发的问题" aria-hidden="true">#</a> <strong>事务并发引发的问题</strong></h3><p><strong>更新丢失(Lost Update)或脏写</strong></p><p>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–<strong>最后的更新覆盖了由其他事务所做的更新</strong>。</p><p><strong>脏读</strong>（Dirty Reads）</p><p><strong>事务A读取到了事务B已经修改但尚未提交的数据</strong>，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求</p><p><strong>不可重复读</strong> （Non-Repeatable Reads）</p><p>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。<strong>事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性</strong></p><p><strong>幻读</strong>（Phantom Reads）</p><p>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</p><p>一句话：<strong>事务A读取到了事务B提交的新增数据，不符合隔离性</strong></p><h3 id="sql标准中的四种隔离级别" tabindex="-1"><a class="header-anchor" href="#sql标准中的四种隔离级别" aria-hidden="true">#</a> SQL标准中的四种隔离级别</h3><p>“脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由数据库提供一定的事务隔离机制来解决。</p><p>READ UNCOMMITTED：未提交读。</p><p>READ COMMITTED：已提交读。</p><p>REPEATABLE READ：可重复读。</p><p>SERIALIZABLE：可串行化</p><p>SQL 标准中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p><p><img src="https://pic3.zhimg.com/80/v2-b14dc96d875b08890f8630f903b7aa90_1440w.png" alt=""></p><p>也就是说：</p><p>READ UNCOMMITTED 隔离级别下，可能发生脏读、不可重复读和幻读问题。</p><p>READ COMMITTED 隔离级别下，可能发生不可重复读和幻读问题，但是不可以发生脏读问题。</p><p>REPEATABLE READ 隔离级别下，可能发生幻读问题，但是不可以发生脏读和不可重复读的问题。</p><p>SERIALIZABLE 隔离级别下，各种问题都不可以发生。</p><p>数据库的事务隔离越严格,并发副作用越小,但付出的代价也就越大,因为事务隔离实质上就是使事务在一定程度上“串行化”进行,这显然与“并发”是矛盾的。</p><p>同时,不同的应用对读一致性和事务隔离程度的要求也是不同的,比如许多应用对“不可重复读&quot;和“幻读”并不敏感,可能更关心数据并发访问的能力。</p><p><strong>常看当前数据库的事务隔离级别: show variables like &#39;tx_isolation&#39;;</strong></p><p><strong>Mysql默认的事务隔离级别是可重复读</strong></p><p>准备一张表</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>CREATE TABLE `account` (\n`id`  int NOT NULL AUTO_INCREMENT ,\n`name`  varchar(255) NULL ,\n`balance`  int NULL ,\nPRIMARY KEY (`id`)\n)\n;\nINSERT INTO`account` (`name`, `balance`) VALUES (&#39;刘备&#39;, &#39;450&#39;);\nINSERT INTO`account` (`name`, `balance`) VALUES (&#39;张飞&#39;, &#39;16000&#39;);\nINSERT INTO `account` (`name`, `balance`) VALUES (&#39;关羽&#39;, &#39;2400&#39;);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="未提交读-read-uncommited" tabindex="-1"><a class="header-anchor" href="#未提交读-read-uncommited" aria-hidden="true">#</a> 未提交读（READ UNCOMMITED)</h4><p><strong>事务A读取到事务B未提交的数据</strong></p><p>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p><p>设置事务隔离级别</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>set SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>事务A：</p><p><img src="http://img.xxfxpt.top/202112122115341.png" alt="image-20211212211517759"></p><p>在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p><p><img src="http://img.xxfxpt.top/202112122113071.png" alt="image-20211212211335245"></p><p>虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：</p><p><img src="http://img.xxfxpt.top/202112122114351.png" alt="image-20211212211431966"></p><p>一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是<strong>脏数据</strong>.</p><h4 id="已提交读-read-commited" tabindex="-1"><a class="header-anchor" href="#已提交读-read-commited" aria-hidden="true">#</a> 已提交读（READ COMMITED)</h4><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>set SESSION TRANSACTION ISOLATION LEVEL read committed;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以读到已经事务提交的数据,不能出现脏读</p><p>客户端A：</p><p><img src="http://img.xxfxpt.top/202112122118175.png" alt="image-20211212211845738"></p><p>在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p><p><img src="http://img.xxfxpt.top/202112122120548.png" alt="image-20211212212016311"></p><p>客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题</p><p><img src="http://img.xxfxpt.top/202112122121207.png" alt=""></p><p>客户端B的事务提交</p><p><img src="http://img.xxfxpt.top/202112122123506.png" alt="image-20211212212324916"></p><p>客户端A能查到最新的数据，产生了不可重复读。</p><p><img src="http://img.xxfxpt.top/202112122125554.png" alt="image-20211212212534966"></p><h4 id="可重复读-repeatable-read" tabindex="-1"><a class="header-anchor" href="#可重复读-repeatable-read" aria-hidden="true">#</a> 可重复读（REPEATABLE READ）</h4><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>set SESSION TRANSACTION ISOLATION LEVEL repeatable read;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在同一个事务中读到是同一条数据，其他事务修改了读的也是修改前的数据</p><p>不能出现脏读和不可重复读</p><p><strong>特别注意的是MySQL数据库在RR隔离级别时候也解决了幻读问题</strong></p><p>客户端A：</p><p><img src="http://img.xxfxpt.top/202112122127272.png" alt="image-20211212212752659"></p><p>在客户端A的事务提交之前，打开另一个客户端B，更新表account并提交</p><p><img src="http://img.xxfxpt.top/202112122130480.png" alt="image-20211212213046799"></p><p>在客户端A查询表account的所有记录，两次查询结果一样，解决了不可重复读</p><p><img src="http://img.xxfxpt.top//202302151640150.png" alt="image-20211212213153084"></p><p>在客户端B，插入一条新数据后提交</p><p><img src="http://img.xxfxpt.top/202112122137921.png" alt=""></p><p>在客户端A查询表account的所有记录，没有查出新增数据，所以没有出现幻读</p><p><img src="http://img.xxfxpt.top/202112122138409.png" alt=""></p><h4 id="可串行化" tabindex="-1"><a class="header-anchor" href="#可串行化" aria-hidden="true">#</a> 可串行化</h4><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>set SESSION TRANSACTION ISOLATION LEVEL serializable;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在一个事务未提交时候，另外一个事务不能对这个表的数据修改，包括新增、修改、删除</p><p>客户端A：</p><p><img src="http://img.xxfxpt.top/202112122142231.png" alt=""></p><p>打开一个客户端B，并设置当前事务模式为serializable，更新相同的id为1的记录会被阻塞等待，更新id为2的记录可以成功，说明在串行模式下innodb的查询也会被加上行锁。</p><p>如果客户端A执行的是一个范围查询，那么该<strong>范围内的所有行包括每行记录所在的间隙区间范围</strong>(就算该行数据还未被插入也会加锁，这种是间隙锁)<strong>都会被加锁</strong>。此时如果客户端B在该范围内插入数据都会被阻塞，所以就避免了幻读。</p><p>这种隔离级别并发性极低，开发中很少会用到。</p><p><img src="http://img.xxfxpt.top/202112122144052.png" alt=""></p>',101),t=[i];function r(c,d){return a(),s("div",null,t)}const g=e(n,[["render",r],["__file","事务.html.vue"]]);export{g as default};
