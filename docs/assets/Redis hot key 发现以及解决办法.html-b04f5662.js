import{_ as a,W as s,X as r,Y as e,Z as d,a0 as c,a1 as i,F as t}from"./framework-2afc6763.js";const n={},h=i('<p><img src="https://img-blog.csdnimg.cn/img_convert/bd7478fd97889eab83becf76c7e334eb.png" alt=""></p><h3 id="热-key-带来问题" tabindex="-1"><a class="header-anchor" href="#热-key-带来问题" aria-hidden="true">#</a> 热 Key 带来问题</h3><p>所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。</p><p>由于某个 <code>Key</code> 的数据一定是存储到后端某台服务器的 <code>Redis</code> 单个实例上，如果对这个 <code>Key</code> 突然出现大量的请求操作，这样就会造成流量过于集中，达到 <code>Redis</code> 单个实例处理上限，可能会导致 <code>Redis</code> 实例 <code>CPU</code> 使用率 <code>100%</code>，或者是网卡流量达到上限等，对系统的稳定性和可用性造成影响，或者更为严重出现服务器宕机，无法对外提供服务；更有甚者在出现 <code>Redis</code> 服务不可用之后，大量的数据请求全部落地数据库查询上，<code>Redis</code> 都已经顶不住了，数据库也是分分钟挂掉的节奏。</p><ul><li>流量集中，达到服务器处理上限（<code>CPU</code>、网络 <code>IO</code> 等）；</li><li>会影响在同一个 <code>Redis</code> 实例上其他 <code>Key</code> 的读写请求操作；</li><li>热 <code>Key</code> 请求落到同一个 <code>Redis</code> 实例上，无法通过扩容解决；</li><li>大量 <code>Redis</code> 请求失败，查询操作可能打到数据库，拖垮数据库，导致整个服务不可用。</li></ul><h3 id="如何发现热-key" tabindex="-1"><a class="header-anchor" href="#如何发现热-key" aria-hidden="true">#</a> 如何发现热 Key</h3><h4 id="凭借业务经验-预估热-key-出现" tabindex="-1"><a class="header-anchor" href="#凭借业务经验-预估热-key-出现" aria-hidden="true">#</a> 凭借业务经验，预估热 Key 出现</h4><p>根据业务系统上线的一些活动和功能，我们是可以在某些场景下提前预估热 <code>Key</code> 的出现的，比如业务需要进行一场商品秒杀活动，秒杀商品信息和数量一般都会缓存到 <code>Redis</code> 中，这种场景极有可能出现热 <code>Key</code> 问题的。</p><ul><li>优点：简单，凭经验发现热 <code>Key</code>，提早发现提早处理；</li><li>缺点：没有办法预测所有热 <code>Key</code> 出现，比如某些热点新闻事件，无法提前预测。</li></ul><h4 id="客户端进行收集" tabindex="-1"><a class="header-anchor" href="#客户端进行收集" aria-hidden="true">#</a> 客户端进行收集</h4><p>一般我们在连接 <code>Redis</code> 服务器时都要使用专门的 SDK（比如：<code>Java</code> 的客户端工具 <code>Jedis</code>、<code>Redisson</code>），我们可以对客户端工具进行封装，在发送请求前进行收集采集，同时定时把收集到的数据上报到统一的服务进行聚合计算。</p><ul><li>优点：方案简单</li><li>缺点： <ul><li>对客户端代码有一定入侵，或者需要对 <code>SDK</code> 工具进行二次开发；</li><li>没法适应多语言架构，每一种语言的 <code>SDK</code> 都需要进行开发，后期开发维护成本较高。</li></ul></li></ul><h4 id="在代理层进行收集" tabindex="-1"><a class="header-anchor" href="#在代理层进行收集" aria-hidden="true">#</a> 在代理层进行收集</h4><p>如果所有的 <code>Redis</code> 请求都经过 <code>Proxy</code>（代理）的话，可以考虑改动 <code>Proxy</code> 代码进行收集，思路与客户端基本类似。</p><p><img src="http://img.xxfxpt.top/202202281726557.png" alt=""></p><p><strong>hotkeys 参数</strong></p>',16),l=e("code",null,"Redis",-1),p=e("code",null,"4.0.3",-1),y={href:"https://github.com/redis/redis/pull/4392",target:"_blank",rel:"noopener noreferrer"},_=e("code",null,"redis-cli --hotkeys",-1),u=e("code",null,"keyspace",-1),K=e("code",null,"key",-1),k=e("code",null,"scan + object freq",-1),R={href:"https://redis.io/commands/monitor",target:"_blank",rel:"noopener noreferrer"},f=e("code",null,"monitor",-1),m=e("code",null,"Redis",-1),b=e("code",null,"redis-cli monitor",-1),g={href:"https://github.com/facebookarchive/redis-faina",target:"_blank",rel:"noopener noreferrer"},x=i('<h4 id="redis-节点抓包分析" tabindex="-1"><a class="header-anchor" href="#redis-节点抓包分析" aria-hidden="true">#</a> Redis 节点抓包分析</h4><p><code>Redis</code> 客户端使用 <code>TCP</code> 协议与服务端进行交互，通信协议采用的是 <code>RESP</code> 协议。自己写程序监听端口，按照 <code>RESP</code> 协议规则解析数据，进行分析。或者我们可以使用一些抓包工具，比如 <code>tcpdump</code> 工具，抓取一段时间内的流量进行解析。</p><h3 id="热-key-问题解决方案" tabindex="-1"><a class="header-anchor" href="#热-key-问题解决方案" aria-hidden="true">#</a> 热 Key 问题解决方案</h3><h3 id="增加-redis-实例复本数量" tabindex="-1"><a class="header-anchor" href="#增加-redis-实例复本数量" aria-hidden="true">#</a> 增加 Redis 实例复本数量</h3><p>对于出现热 <code>Key</code> 的 <code>Redis</code> 实例，我们可以通过水平扩容增加副本数量，将读请求的压力分担到不同副本节点上。</p><h3 id="二级缓存-本地缓存" tabindex="-1"><a class="header-anchor" href="#二级缓存-本地缓存" aria-hidden="true">#</a> 二级缓存（本地缓存）</h3><p>当出现热 <code>Key</code> 以后，把热 <code>Key</code> 加载到系统的 <code>JVM</code> 中。后续针对这些热 <code>Key</code> 的请求，会直接从 <code>JVM</code> 中获取，而不会走到 <code>Redis</code> 层。这些本地缓存的工具很多，比如 <code>Ehcache</code>，或者 <code>Google Guava</code> 中 <code>Cache</code> 工具，或者直接使用 <code>HashMap</code> 作为本地缓存工具都是可以的。</p><p><strong>使用本地缓存需要注意两个问题：</strong></p><ul><li>如果对热 <code>Key</code> 进行本地缓存，需要防止本地缓存过大，影响系统性能；</li><li>需要处理本地缓存和 <code>Redis</code> 集群数据的一致性问题。</li></ul><h3 id="热-key-备份" tabindex="-1"><a class="header-anchor" href="#热-key-备份" aria-hidden="true">#</a> 热 Key 备份</h3><p>通过前面的分析，我们可以了解到，之所以出现热 <code>Key</code>，是因为有大量的对同一个 <code>Key</code> 的请求落到同一个 <code>Redis</code> 实例上，如果我们可以有办法将这些请求打散到不同的实例上，防止出现流量倾斜的情况，那么热 <code>Key</code> 问题也就不存在了。</p><p>那么如何将对某个热 <code>Key</code> 的请求打散到不同实例上呢？我们就可以通过热 <code>Key</code> 备份的方式，基本的思路就是，我们可以给热 <code>Key</code> 加上前缀或者后缀，把一个热 <code>Key</code> 的数量变成 <code>Redis</code> 实例个数 <code>N</code> 的倍数 <code>M</code>，从而由访问一个 <code>Redis</code> <code>Key</code> 变成访问 <code>N * M</code> 个 <code>Redis</code> <code>Key</code>。 <code>N * M</code> 个 <code>Redis</code> <code>Key</code> 经过分片分布到不同的实例上，将访问量均摊到所有实例。</p><p><img src="http://img.xxfxpt.top/202202281729616.png" alt=""></p><p>在这段代码中，通过一个大于等于 <code>1</code> 小于 <code>M</code> 的随机数，得到一个 <code>bakHotKey</code>，程序会优先访问 <code>bakHotKey</code>，在得不到数据的情况下，再访问原来的 <code>hotkey</code>，并将 <code>hotkey</code> 的内容写回 <code>bakHotKey</code>。值得注意的是，<code>bakHotKey</code> 的过期时间是 <code>hotkey</code> 的过期时间加上一个较小的随机正整数，这是通过坡度过期的方式，保证在 <code>hotkey</code> 过期时，所有 <code>bakHotKey</code> 不会同时过期而造成缓存雪崩。</p><p>使用京东框架发现热key，https://gitee.com/jd-platform-opensource/hotkey</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>在这一篇文章中我们首先分析了在 <code>Redis</code> 中热 <code>Key</code> 带来的一些问题，同时也介绍了在海量的 <code>Redis</code> <code>Key</code> 中找到热 <code>Key</code> 的一些方法，最后也提到了在解决热 <code>Key</code> 问题中我们常用的一些办法；总结来说，<code>Redis</code> 热 <code>Key</code> 问题首先是请求流量过大造成的，但是更深层次原因还是出现了流量倾斜，单个 <code>Redis</code> 实例承担的流量过大造成的，了解到了本质原因，解决的思路也就简单了，就是要想尽一切办法将单个实例承担的流量打散，让每个机器均衡承担热 <code>Key</code> 的流量，不要出现流量倾斜，保证系统的稳定性。</p>',17);function v(M,N){const o=t("ExternalLinkIcon");return s(),r("div",null,[h,e("p",null,[l,d(" 在 "),p,d(" 版本中添加了 "),e("a",y,[d("hotkeys"),c(o)]),d(" 查找特性，可以直接利用 "),_,d(" 获取当前 "),u,d(" 的热点 "),K,d("，实现上是通过 "),k,d(" 完成的。")]),e("p",null,[e("strong",null,[e("a",R,[d("monitor"),c(o)]),d(" 命令")])]),e("p",null,[f,d(" 命令可以实时抓取出 "),m,d(" 服务器接收到的命令，通过 "),b,d(" 抓取数据，同时结合一些现成的分析工具，比如 "),e("a",g,[d("redis-faina"),c(o)]),d("，统计出热 Key。")]),x])}const E=a(n,[["render",v],["__file","Redis hot key 发现以及解决办法.html.vue"]]);export{E as default};
