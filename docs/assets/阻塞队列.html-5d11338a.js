import{_ as e,W as i,X as r,a1 as o}from"./framework-2afc6763.js";const n={},l=o('<h4 id="什么是阻塞队列" tabindex="-1"><a class="header-anchor" href="#什么是阻塞队列" aria-hidden="true">#</a> 什么是阻塞队列</h4><p>1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程， 直到队列不满。</p><p>2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队 列变为非空。 在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式 通过平衡生产线程和消费线程的工作能力来提高程序整体处理数据的速度。</p><p>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。 在多线程开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产 者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处 理能力大于生产者，那么消费者就必须等待生产者。</p><p>为了解决这种生产消费能力不均衡的问题，便有了生产者和消费者模式。生 产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者 和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产 完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据， 而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费 者的处理能力。</p><p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程， 消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用 来获取元素的容器。</p><p><img src="https://pica.zhimg.com/80/v2-89e8ffc36ab254122764d68d4c76658a_720w.png" alt=""></p><ul><li><p>抛出异常：当队列满时，如果再往队列里插入元素，会抛出 IllegalStateException（&quot;Queuefull&quot;）异常。当队列空时，从队列里获取元素会抛 出 NoSuchElementException 异常。</p></li><li><p>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回 true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回 null。</p></li><li><p>一直阻塞：当阻塞队列满时，如果生产者线程往队列里 put 元素，队列会 一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费 者线程从队列里 take 元素，队列会阻塞住消费者线程，直到队列不为空。</p></li><li><p>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会 阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</p></li></ul><h4 id="常用阻塞队列" tabindex="-1"><a class="header-anchor" href="#常用阻塞队列" aria-hidden="true">#</a> <strong>常用阻塞队列</strong></h4><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul><p>以上的阻塞队列都实现了 BlockingQueue 接口，也都是线程安全的。</p><h4 id="有界无界" tabindex="-1"><a class="header-anchor" href="#有界无界" aria-hidden="true">#</a> 有界无界？</h4><p>​ 有限队列就是长度有限，满了以后生产者会阻塞，无界队列就是里面能放 无数的东西而不会因为队列长度限制被阻塞，当然空间限制来源于系统资源的限 制，如果处理不及时，导致队列越来越大越来越大，超出一定的限制致使内存超 限，操作系统或者 JVM 帮你解决烦恼，直接把你 OOM kill 省事了。 无界也会阻塞，为何？因为阻塞不仅仅体现在生产者放入元素时会阻塞， 消费者拿取元素时，如果没有元素，同样也会阻塞。</p><h4 id="arrayblockingqueue" tabindex="-1"><a class="header-anchor" href="#arrayblockingqueue" aria-hidden="true">#</a> <strong>ArrayBlockingQueue</strong></h4><p>​ 是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对 元素进行排序。默认情况下不保证线程公平的访问队列，所谓公平访问队列是指 阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非 公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访 问队列的资格，有可能先阻塞的线程最后才访问队列。初始化时有参数可以设置。</p><p><strong>LinkedBlockingQueue</strong></p><p>是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p><p><strong>Array</strong> <strong>实现和</strong> <strong>Linked</strong> <strong>实现的区别</strong></p><ol><li>队列中锁的实现不同</li></ol><p>ArrayBlockingQueue 实现的队列中的锁是没有分离的，即生产和消费用的是 同一个锁；</p><p>LinkedBlockingQueue 实现的队列中的锁是分离的，即生产用的是 putLock， 消费是 takeLock</p><ol start="2"><li>在生产或消费时操作不同</li></ol><p>ArrayBlockingQueue 实现的队列中在生产和消费的时候，是直接将枚举对象 插入或移除的；</p><p>LinkedBlockingQueue 实现的队列中在生产和消费的时候，需要把枚举对象转 换为 <code>Node&lt;E&gt;</code>进行插入或移除，会影响性能</p><ol start="3"><li>队列大小初始化方式不同</li></ol><p>ArrayBlockingQueue 实现的队列中必须指定队列的大小；</p><p>LinkedBlockingQueue 实现的队列中可以不指定队列的大小，但是默认是 Integer.MAX_VALUE</p><p><strong>PriorityBlockingQueue</strong></p><p>PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素 采取自然顺序升序排列。也可以自定义类实现 compareTo()方法来指定元素排序</p><p>规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素 进行排序。需要注意的是不能保证同优先级元素的顺序。</p><p><strong>DelayQueue</strong></p><p>是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。 队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中</p><p>获取当前元素。只有在延迟期满时才能从队列中提取元素。</p><p>**缓存系统的设计：**可以用 DelayQueue 保存缓存元素的有效期，使用一个线 程循环查询 DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期</p><p>到了。<strong>还有订单到期，限时支付等等</strong></p><p><img src="https://pica.zhimg.com/80/v2-2a6b2f4c296126b4fee5586659762101_720w.png" alt=""></p><p><strong>SynchronousQueue</strong></p><p>是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作， 否则不能继续添加元素。SynchronousQueue 可以看成是一个传球手，负责把生 产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常 适合传递性场景。SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue。</p>',38),u=[l];function t(p,a){return i(),r("div",null,u)}const s=e(n,[["render",t],["__file","阻塞队列.html.vue"]]);export{s as default};
