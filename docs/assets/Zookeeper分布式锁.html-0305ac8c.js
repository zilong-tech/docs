import{_ as e,W as c,X as a,a1 as t}from"./framework-2afc6763.js";const p={},r=t('<h3 id="zookeeper分布式锁" tabindex="-1"><a class="header-anchor" href="#zookeeper分布式锁" aria-hidden="true">#</a> <strong>Zookeeper分布式锁</strong></h3><h4 id="_1、非公平锁" tabindex="-1"><a class="header-anchor" href="#_1、非公平锁" aria-hidden="true">#</a> <strong>1</strong>、非公平锁：</h4><p><img src="https://pic2.zhimg.com/80/v2-72fa1ef75781df722e55b916b2360352_720w.png" alt=""></p><p>如上实现方式在并发问题比较严重的情况下，性能会下降的比较厉害，主要原因是，所有的连接 都在对同一个节点进行监听，当服务器检测到删除事件时，要通知所有的连接，所有的连接同时 收到事件，再次并发竞争，这就是<strong>羊群效应</strong>。</p><img src="https://pic2.zhimg.com/80/v2-043975f222aa215527835a6b0a998384_720w.png"><img src="https://pic1.zhimg.com/80/v2-f0f4ff87d7f1e3701ef34d5c3a8685de_720w.png"><h3 id="_2、公平锁" tabindex="-1"><a class="header-anchor" href="#_2、公平锁" aria-hidden="true">#</a> 2、公平锁</h3><p><img src="https://pic3.zhimg.com/80/v2-145cfc5f6d4714c84721c4387bfec729_720w.png" alt=""></p><p>1、直接在/lock节点下创建一个临时有序节点</p><p>2、判断是不是/lock节点下最小的节点</p><ul><li><p>是最小的，获得锁</p></li><li><p>不是最小的，对前面的节点进行监听watch</p></li></ul><p>3、获得锁的请求，处理完释放锁，删除节点，然后后继第一个节点将收到通知，重复步骤2的判断</p><p><img src="https://pic1.zhimg.com/80/v2-12be4591c3cc4f2489ffc742a873bf72_720w.png" alt=""></p><p><img src="https://pic2.zhimg.com/80/v2-f1ea0008e6ebf5124a19d07a392e721f_720w.png" alt=""></p>',14),i=[r];function o(s,h){return c(),a("div",null,i)}const f=e(p,[["render",o],["__file","Zookeeper分布式锁.html.vue"]]);export{f as default};
