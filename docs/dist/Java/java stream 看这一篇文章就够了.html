<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://zilong-tech.github.io/docs/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html"><meta property="og:site_name" content="子龙技术"><meta property="og:title" content="java stream 看这一篇文章就够了"><meta property="og:description" content="Lambda表达式简介 Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 使用 Lambda 表达式可以使代码变的更加简洁紧凑。 可以把Lambda表达式理解为简洁的表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表，函数主体，返回类型，可..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-02-15T08:23:34.000Z"><meta property="article:author" content="程序员子龙"><meta property="article:modified_time" content="2023-02-15T08:23:34.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"java stream 看这一篇文章就够了","image":[""],"dateModified":"2023-02-15T08:23:34.000Z","author":[{"@type":"Person","name":"程序员子龙"}]}</script><title>java stream 看这一篇文章就够了 | 子龙技术</title><meta name="description" content="Lambda表达式简介 Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 使用 Lambda 表达式可以使代码变的更加简洁紧凑。 可以把Lambda表达式理解为简洁的表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表，函数主体，返回类型，可...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/docs/assets/style-84ad0583.css" as="style"><link rel="stylesheet" href="/docs/assets/style-84ad0583.css">
    <link rel="modulepreload" href="/docs/assets/app-cec6d41f.js"><link rel="modulepreload" href="/docs/assets/framework-2afc6763.js"><link rel="modulepreload" href="/docs/assets/java stream 看这一篇文章就够了.html-42b1dbb0.js"><link rel="modulepreload" href="/docs/assets/java stream 看这一篇文章就够了.html-c3d665ca.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/docs/" class="brand"><img class="logo" src="/docs/logo.png" alt="子龙技术"><!----><span class="site-name hide-in-pad">子龙技术</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="nav-link" aria-label="并发编程"><span class="font-icon icon info" style=""></span>并发编程<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="nav-link" aria-label="网络编程"><span class="font-icon icon info" style=""></span>网络编程<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="分布式"><span class="title"><span class="font-icon icon info" style=""></span>分布式</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/docs/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/" class="nav-link" aria-label="分布式基础"><span class="font-icon icon creative" style=""></span>分布式基础<!----></a></li><li class="dropdown-item"><a href="/docs/zookeeper/" class="nav-link" aria-label="zookeeper"><span class="font-icon icon creative" style=""></span>zookeeper<!----></a></li><li class="dropdown-item"><a href="/docs/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" class="nav-link" aria-label="分布式事务"><span class="font-icon icon creative" style=""></span>分布式事务<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="微服务"><span class="title"><span class="font-icon icon info" style=""></span>微服务</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/docs/SpringBoot/" class="nav-link" aria-label="SpringBoot"><span class="font-icon icon creative" style=""></span>SpringBoot<!----></a></li><li class="dropdown-item"><a href="/docs/SpringCloudAlibaba/" class="nav-link" aria-label="SpringCloudAlibaba"><span class="font-icon icon creative" style=""></span>SpringCloudAlibaba<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/docs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="nav-link" aria-label="设计模式"><span class="font-icon icon info" style=""></span>设计模式<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/Java/" class="nav-link active" aria-label="Java"><span class="font-icon icon info" style=""></span>Java<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/JVM/" class="nav-link" aria-label="JVM"><span class="font-icon icon info" style=""></span>JVM<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="数据库"><span class="title"><span class="font-icon icon info" style=""></span>数据库</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/docs/Redis/" class="nav-link" aria-label="Redis"><span class="font-icon icon info" style=""></span>Redis<!----></a></li><li class="dropdown-item"><a href="/docs/MySQL/" class="nav-link" aria-label="MySQL"><span class="font-icon icon info" style=""></span>MySQL<!----></a></li><li class="dropdown-item"><a href="/docs/Mongodb/" class="nav-link" aria-label="Mongodb"><span class="font-icon icon info" style=""></span>Mongodb<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/docs/Mybatis/" class="nav-link" aria-label="Mybatis"><span class="font-icon icon info" style=""></span>Mybatis<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/Spring/" class="nav-link" aria-label="Spring"><span class="font-icon icon info" style=""></span>Spring<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="消息中间件"><span class="title"><span class="font-icon icon info" style=""></span>消息中间件</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/docs/Kafka/" class="nav-link" aria-label="Kafka"><span class="font-icon icon creative" style=""></span>Kafka<!----></a></li><li class="dropdown-item"><a href="/docs/RocketMQ/" class="nav-link" aria-label="RocketMQ"><span class="font-icon icon creative" style=""></span>RocketMQ<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/docs/%E9%AB%98%E5%B9%B6%E5%8F%91/" class="nav-link" aria-label="高并发"><span class="font-icon icon info" style=""></span>高并发<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/%E9%9D%A2%E8%AF%95/" class="nav-link" aria-label="面试"><span class="font-icon icon info" style=""></span>面试<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/%E5%B7%A5%E5%85%B7/" class="nav-link" aria-label="工具"><span class="font-icon icon info" style=""></span>工具<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/" class="nav-link" aria-label="开源项目"><span class="font-icon icon info" style=""></span>开源项目<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!----><!----><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/docs/Java/%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%B3%A8%E8%A7%A3%E5%80%BC.html" class="nav-link sidebar-link sidebar-page" aria-label="动态修改注解值"><span class="font-icon icon discover" style=""></span>动态修改注解值<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/Java/%E8%BF%98%E5%9C%A8%E7%94%A8try%20catch%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%EF%BC%9F.html" class="nav-link sidebar-link sidebar-page" aria-label="还在用try catch处理异常？"><span class="font-icon icon discover" style=""></span>还在用try catch处理异常？<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/Java/%E6%B3%9B%E5%9E%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="什么是泛型"><span class="font-icon icon discover" style=""></span>什么是泛型<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/Java/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%A8%E8%A7%A3%EF%BC%9F.html" class="nav-link sidebar-link sidebar-page" aria-label="什么是注解"><span class="font-icon icon discover" style=""></span>什么是注解<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/Java/%E6%8E%A8%E8%8D%90%E4%B9%A6%E5%8D%95.html" class="nav-link sidebar-link sidebar-page" aria-label="推荐书单"><span class="font-icon icon discover" style=""></span>推荐书单<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/Java/FIFO%20%E3%80%81LRU%E3%80%81LFU%E7%AE%97%E6%B3%95.html" class="nav-link sidebar-link sidebar-page" aria-label="FIFO 、LRU、LFU算法"><span class="font-icon icon discover" style=""></span>FIFO 、LRU、LFU算法<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/Java/HashMap.html" class="nav-link sidebar-link sidebar-page" aria-label="HashMap 详解"><span class="font-icon icon discover" style=""></span>HashMap 详解<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/Java/Java%20%E6%A8%A1%E6%9D%BF%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%8D%A0%E4%BD%8D%E7%AC%A6%E6%9B%BF%E6%8D%A2%EF%BC%89.html" class="nav-link sidebar-link sidebar-page" aria-label="Java 模板变量替换（字符串、占位符替换）"><span class="font-icon icon discover" style=""></span>Java 模板变量替换（字符串、占位符替换）<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/Java/java%E5%9F%BA%E7%A1%80.html" class="nav-link sidebar-link sidebar-page" aria-label="java 学习路线图"><span class="font-icon icon discover" style=""></span>java 学习路线图<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/Java/Java%20SPI%E8%AF%A6%E8%A7%A3.html" class="nav-link sidebar-link sidebar-page" aria-label="Java SPI 详解"><span class="font-icon icon discover" style=""></span>Java SPI 详解<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="java stream 看这一篇文章就够了"><span class="font-icon icon discover" style=""></span>java stream 看这一篇文章就够了<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#lambda表达式简介" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Lambda表达式简介"><!---->Lambda表达式简介<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#函数式接口" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="函数式接口"><!---->函数式接口<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#function" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Function"><!---->Function<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#接收单个参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="接收单个参数"><!---->接收单个参数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#接收两个参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="接收两个参数"><!---->接收两个参数<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#consumer" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Consumer"><!---->Consumer<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#接收一个参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="接收一个参数"><!---->接收一个参数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#接收两个参数-1" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="接收两个参数"><!---->接收两个参数<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#supplier" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Supplier"><!---->Supplier<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#predicate" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Predicate"><!---->Predicate<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#方法引用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="方法引用"><!---->方法引用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#stream" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Stream"><!---->Stream<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#什么是-stream" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="什么是 Stream？"><!---->什么是 Stream？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#怎么使用stream" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="怎么使用Stream？"><!---->怎么使用Stream？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#创建流" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="创建流"><!---->创建流<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#stream方法使用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="stream方法使用"><!---->stream方法使用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#foreach" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="forEach()"><!---->forEach()<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#filter" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="filter()"><!---->filter()<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#distinct" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="distinct()"><!---->distinct()<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#sorted" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="sorted()"><!---->sorted()<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#map" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="map()"><!---->map()<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#flatmap" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="flatMap()"><!---->flatMap()<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#规约操作" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="规约操作"><!---->规约操作<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#reduce" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="reduce()"><!---->reduce()<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#collect" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="collect()"><!---->collect()<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/docs/Java/jdk%E4%BB%A3%E7%90%86.html" class="nav-link sidebar-link sidebar-page" aria-label="JDK 代理"><span class="font-icon icon discover" style=""></span>JDK 代理<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/Java/jdk%20spring%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB.html" class="nav-link sidebar-link sidebar-page" aria-label="JDK Spring内置工具类"><span class="font-icon icon discover" style=""></span>JDK Spring内置工具类<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><span class="font-icon icon discover" style=""></span>java stream 看这一篇文章就够了</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">程序员子龙</span></span><span property="author" content="程序员子龙"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-02-15T08:23:34.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 19 分钟</span><meta property="timeRequired" content="PT19M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><span class="page-category-item category8" role>Java 基础</span><meta property="articleSection" content="Java 基础"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容<button class="print-button" title="print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#lambda表达式简介" class="router-link-active router-link-exact-active toc-link level3">Lambda表达式简介</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#函数式接口" class="router-link-active router-link-exact-active toc-link level3">函数式接口</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#function" class="router-link-active router-link-exact-active toc-link level2">Function</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#接收单个参数" class="router-link-active router-link-exact-active toc-link level3">接收单个参数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#接收两个参数" class="router-link-active router-link-exact-active toc-link level3">接收两个参数</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#consumer" class="router-link-active router-link-exact-active toc-link level2">Consumer</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#接收一个参数" class="router-link-active router-link-exact-active toc-link level3">接收一个参数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#接收两个参数-1" class="router-link-active router-link-exact-active toc-link level3">接收两个参数</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#supplier" class="router-link-active router-link-exact-active toc-link level2">Supplier</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#predicate" class="router-link-active router-link-exact-active toc-link level2">Predicate</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#方法引用" class="router-link-active router-link-exact-active toc-link level3">方法引用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#stream" class="router-link-active router-link-exact-active toc-link level3">Stream</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#什么是-stream" class="router-link-active router-link-exact-active toc-link level3">什么是 Stream？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#怎么使用stream" class="router-link-active router-link-exact-active toc-link level3">怎么使用Stream？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#创建流" class="router-link-active router-link-exact-active toc-link level3">创建流</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#stream方法使用" class="router-link-active router-link-exact-active toc-link level3">stream方法使用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#foreach" class="router-link-active router-link-exact-active toc-link level3">forEach()</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#filter" class="router-link-active router-link-exact-active toc-link level3">filter()</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#distinct" class="router-link-active router-link-exact-active toc-link level3">distinct()</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#sorted" class="router-link-active router-link-exact-active toc-link level3">sorted()</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#map" class="router-link-active router-link-exact-active toc-link level3">map()</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#flatmap" class="router-link-active router-link-exact-active toc-link level3">flatMap()</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#规约操作" class="router-link-active router-link-exact-active toc-link level3">规约操作</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#reduce" class="router-link-active router-link-exact-active toc-link level3">reduce()</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Java/java%20stream%20%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86.html#collect" class="router-link-active router-link-exact-active toc-link level3">collect()</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h3 id="lambda表达式简介" tabindex="-1"><a class="header-anchor" href="#lambda表达式简介" aria-hidden="true">#</a> Lambda表达式简介</h3><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p><p>可以把Lambda表达式理解为简洁的表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表，函数主体，返回类型，可能还有一个可以抛出的异常列表。</p><h4 id="语法" tabindex="-1"><a class="header-anchor" href="#语法" aria-hidden="true">#</a> 语法</h4><p>java中，引入了一个新的操作符“-&gt;”，该操作符在很多资料中，称为箭头操作符，或者lambda操作符；箭头操作符将lambda分成了两个部分：</p><ol><li><p>左侧：lambda表达式的参数列表</p></li><li><p>右侧：lambda表达式中所需要执行的功能，即lambda函数体</p></li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  (parameters) -&gt; expression

   或 
   
   (parameters) -&gt;{ statements; }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>**可选类型声明：**不需要声明参数类型，编译器可以统一识别参数值。</p></li><li><p>**可选的参数圆括号：**一个参数无需定义圆括号，但多个参数需要定义圆括号。</p></li><li><p>**可选的大括号：**如果主体包含了一个语句，就不需要使用大括号。</p></li><li><p>**可选的返回关键字：**如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。</p></li></ul><p>语法格式：</p><p>A.无参数，无返回值的用法 ：() -&gt; System.out.println(&quot;hello lambda&quot;);</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    @Test
	public void test1() {
		Runnable r = new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;hello runnable&quot;);
			}
		};
		r.run();
		
		
		Runnable r1 = () -&gt; System.out.println(&quot;hello lambda&quot;);
		r1.run();
	}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>B.带参函数</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// JDK7 匿名内部类写法
List&lt;String&gt; list = Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);
Collections.sort(list, new Comparator&lt;String&gt;(){// 接口名
    @Override
    public int compare(String s1, String s2){// 方法名
        if(s1 == null)
            return -1;
        if(s2 == null)
            return 1;
        return s1.length()-s2.length();
    }
});

// JDK8 Lambda表达式写法
List&lt;String&gt; list = Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);
Collections.sort(list, (s1, s2) -&gt;{// 省略参数表的类型
    if(s1 == null)
        return -1;
    if(s2 == null)
        return 1;
    return s1.length()-s2.length();
});
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>C.lambda表达式中，多行语句，分别在无返回值和有返回值的抽象类中的用法</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@Test
public void test4() {
    // 无返回值lambda函数体中用法
    Runnable r1 = () -&gt; {
    System.out.println(&quot;hello lambda1&quot;);
    System.out.println(&quot;hello lambda2&quot;);
    System.out.println(&quot;hello lambda3&quot;);
};
r1.run();

// 有返回值lambda函数体中用法
BinaryOperator&lt;Integer&gt; binary = (x, y) -&gt; {
    int a = x * 2;
    int b = y + 2;
    return a + b;
};
System.out.println(binary.apply(1, 2));// 6
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，多行的，只需要用大括号{}把语句包含起来就可以了；有返回值和无返回值的，只有一个return的区别；只有一条语句的，大括号和renturn都可以不用写；</p><p>D. lambda的类型推断</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    @Test
	public void test5() {
		BinaryOperator binary = (Integer x, Integer y) -&gt; x + y;
		System.out.println(binary.apply(1, 2));// 3
	}


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在lambda中的参数列表，可以不用写参数的类型，跟java7中 new ArrayList&lt;&gt;(); 不需要指定泛型类型，这样的&lt;&gt;棱形操作符一样，根据上下文做类型的推断</p><p><strong>能够使用Lambda的依据是必须有相应的函数接口</strong>（函数接口，是指内部只有一个抽象方法的接口）。这一点跟Java是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写Lambda表达式。实际上<em>Lambda的类型就是对应函数接口的类型</em>。<strong>Lambda表达式另一个依据是类型推断机制</strong>，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。Lambda表达更多合法的书写形式如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// Lambda表达式的书写形式</span>
<span class="token class-name">Runnable</span> run <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;button clicked&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2</span>
<span class="token class-name">Runnable</span> multiLine <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span><span class="token comment">// 3 代码块</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot; Hoolee&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">BinaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> add <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Long</span> x<span class="token punctuation">,</span> <span class="token class-name">Long</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token comment">// 4</span>
<span class="token class-name">BinaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> addImplicit <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token comment">// 5 类型推断</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="函数式接口" tabindex="-1"><a class="header-anchor" href="#函数式接口" aria-hidden="true">#</a> 函数式接口</h3><p>函数式接口(Functional Interface)是Java 8对一类特殊类型的接口的称呼。 这类接口只定义了唯一的抽象方法的接口，并且这类接口使用了<code>@FunctionalInterface</code>进行注解。函数式接口可以被隐式转换为 lambda 表达式。在jdk8中，引入了一个新的包<code>java.util.function</code>, 可以使java 8 的函数式编程变得更加简便。这个package中的接口大致分为了以下四类：</p><ul><li><p>Function: 接收参数，并返回结果，主要方法 <code>R apply(T t)</code></p></li><li><p>Consumer: 接收参数，无返回结果, 主要方法为 <code>void accept(T t)</code></p></li><li><p>Supplier: 不接收参数，但返回结构，主要方法为 <code>T get()</code></p></li><li><p>Predicate: 接收参数，返回boolean值，主要方法为 <code>boolean test(T t)</code></p><p><img src="https://pica.zhimg.com/80/v2-6333a74781eea89a3d6b3b33fd88b465_720w.png" alt=""></p></li></ul><h2 id="function" tabindex="-1"><a class="header-anchor" href="#function" aria-hidden="true">#</a> Function</h2><p>表示一个方法接收参数并返回结果。</p><h3 id="接收单个参数" tabindex="-1"><a class="header-anchor" href="#接收单个参数" aria-hidden="true">#</a> 接收单个参数</h3><table><thead><tr><th>Interface</th><th>functional method</th><th>说明</th></tr></thead><tbody><tr><td>Function&lt;T,R</td><td>R apply(T t)</td><td>接收参数类型为T，返回参数类型为R</td></tr><tr><td>IntFunction</td><td>R apply(int value)</td><td>以下三个接口，指定了接收参数类型，返回参数类型为泛型R</td></tr><tr><td>LongFunction</td><td>R apply(long value)</td><td></td></tr><tr><td>Double</td><td>R apply(double value)</td><td></td></tr><tr><td>ToIntFunction</td><td>int applyAsInt(T value)</td><td>以下三个接口，指定了返回参数类型，接收参数类型为泛型T</td></tr><tr><td>ToLongFunction</td><td>long applyAsLong(T value)</td><td></td></tr><tr><td>ToDoubleFunction</td><td>double applyAsDouble(T value)</td><td></td></tr><tr><td>IntToLongFunction</td><td>long applyAsLong(int value)</td><td>以下六个接口，既指定了接收参数类型，也指定了返回参数类型</td></tr><tr><td>IntToDoubleFunction</td><td>double applyAsLong(int value)</td><td></td></tr><tr><td>LongToIntFunction</td><td>int applyAsLong(long value)</td><td></td></tr><tr><td>LongToDoubleFunction</td><td>double applyAsLong(long value)</td><td></td></tr><tr><td>DoubleToIntFunction</td><td>int applyAsLong(double value)</td><td></td></tr><tr><td>DoubleToLongFunction</td><td>long applyAsLong(double value)</td><td></td></tr><tr><td>UnaryOperator</td><td>T apply(T t)</td><td>特殊的Function，接收参数类型和返回参数类型一样</td></tr><tr><td>IntUnaryOperator</td><td>int applyAsInt(int left, int right)</td><td>以下三个接口，指定了接收参数和返回参数类型，并且都一样</td></tr><tr><td>LongUnaryOperator</td><td>long applyAsInt(long left, long right)</td><td></td></tr><tr><td>DoubleUnaryOperator</td><td>double applyAsInt(double left, double right)</td><td></td></tr></tbody></table><h3 id="接收两个参数" tabindex="-1"><a class="header-anchor" href="#接收两个参数" aria-hidden="true">#</a> 接收两个参数</h3><table><thead><tr><th>interface</th><th>functional method</th><th>说明</th></tr></thead><tbody><tr><td>BiFunction&lt;T,U,R&gt;</td><td>R apply(T t, U u)</td><td>接收两个参数的Function</td></tr><tr><td>ToIntBiFunction&lt;T,U&gt;</td><td>int applyAsInt(T t, U u)</td><td>以下三个接口，指定了返回参数类型，接收参数类型分别为泛型T, U</td></tr><tr><td>ToLongBiFunction&lt;T,U&gt;</td><td>long applyAsLong(T t, U u)</td><td></td></tr><tr><td>ToDoubleBiFunction&lt;T,U&gt;</td><td>double appleyAsDouble(T t, U u)</td><td></td></tr><tr><td>BinaryOperator</td><td>T apply(T t, T u)</td><td>特殊的BiFunction, 接收参数和返回参数类型一样</td></tr><tr><td>IntBinaryOperator</td><td>int applyAsInt(int left, int right)</td><td></td></tr><tr><td>LongBinaryOperator</td><td>long applyAsInt(long left, long right)</td><td></td></tr><tr><td>DoubleBinaryOperator</td><td>double applyAsInt(double left, double right)</td><td></td></tr></tbody></table><h2 id="consumer" tabindex="-1"><a class="header-anchor" href="#consumer" aria-hidden="true">#</a> Consumer</h2><p>表示一个方法接收参数但不产生返回值。</p><h3 id="接收一个参数" tabindex="-1"><a class="header-anchor" href="#接收一个参数" aria-hidden="true">#</a> 接收一个参数</h3><table><thead><tr><th>interface</th><th>functional method</th><th>说明</th></tr></thead><tbody><tr><td>Consumer</td><td>void accept(T t)</td><td>接收一个泛型参数，无返回值</td></tr><tr><td>IntConsumer</td><td>void accept(int value)</td><td>以下三个类，接收一个指定类型的参数</td></tr><tr><td>LongConsumer</td><td>void accept(long value)</td><td></td></tr><tr><td>DoubleConsumer</td><td>void accept(double value)</td><td></td></tr></tbody></table><h3 id="接收两个参数-1" tabindex="-1"><a class="header-anchor" href="#接收两个参数-1" aria-hidden="true">#</a> 接收两个参数</h3><table><thead><tr><th>interface</th><th>functional method</th><th>说明</th></tr></thead><tbody><tr><td>BiConsumer&lt;T,U&gt;</td><td>void accept(T t, U u)</td><td>接收两个泛型参数</td></tr><tr><td>ObjIntConsumer</td><td>void accept(T t, int value)</td><td>以下三个类，接收一个泛型参数，一个指定类型的参数</td></tr><tr><td>ObjLongConsumer</td><td>void accept(T t, long value)</td><td></td></tr><tr><td>ObjDoubleConsumer</td><td>void accept(T t, double value)</td><td></td></tr></tbody></table><h2 id="supplier" tabindex="-1"><a class="header-anchor" href="#supplier" aria-hidden="true">#</a> Supplier</h2><p>返回一个结果，并不要求每次调用都返回一个新的或者独一的结果</p><table><thead><tr><th>interface</th><th>functional method</th><th>说明</th></tr></thead><tbody><tr><td>Supplier</td><td>T get()</td><td>返回类型为泛型T</td></tr><tr><td>BooleanSupplier</td><td>boolean getAsBoolean()</td><td>以下三个接口，返回指定类型</td></tr><tr><td>IntSupplier</td><td>int getAsInt()</td><td></td></tr><tr><td>LongSupplier</td><td>long getAsLong()</td><td></td></tr><tr><td>DoubleSupplier</td><td>double getAsDouble()</td><td></td></tr></tbody></table><h2 id="predicate" tabindex="-1"><a class="header-anchor" href="#predicate" aria-hidden="true">#</a> Predicate</h2><p>根据接收参数进行断言，返回boolean类型</p><table><thead><tr><th>interface</th><th>functional method</th><th>说明</th></tr></thead><tbody><tr><td>Predicate</td><td>boolean test(T t)</td><td>接收一个泛型参数</td></tr><tr><td>IntPredicate</td><td>boolean test(int value)</td><td>以下三个接口，接收指定类型的参数</td></tr><tr><td>LongPredicate</td><td>boolean test(long value)</td><td></td></tr><tr><td>DoublePredicate</td><td>boolean test(double value)</td><td></td></tr><tr><td>BiPredicate&lt;T,U&gt;</td><td>boolean test(T t, U u)</td><td>接收两个泛型参数，分别为T，U</td></tr></tbody></table><p>自定义函数式接口</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@FunctionalInterface
interface GreetingService {
    void sayMessage(String message);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>GreetingService greetService1 = message -&gt; System.out.println(&quot;Hello &quot; + message);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>jdk7写法是这样的</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>GreetingService greetService1 = new GreetingService() {
    @Override
    public void sayMessage(String message) {
        System.out.println(&quot;Hello &quot; + message);
    }
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="方法引用" tabindex="-1"><a class="header-anchor" href="#方法引用" aria-hidden="true">#</a> 方法引用</h3><p>方法引用使用一对冒号 <strong>::</strong> 。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@FunctionalInterface
public interface Supplier&lt;T&gt; {

    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}


    class Car {
        //Supplier是jdk1.8的接口，这里和lamda一起使用了
        public static Car create(final Supplier&lt;Car&gt; supplier) {
            return supplier.get();
        }

        public static void collide(final Car car) {
            System.out.println(&quot;Collided &quot; + car.toString());
        }

        public void follow(final Car another) {
            System.out.println(&quot;Following the &quot; + another.toString());
        }

        public void repair() {
            System.out.println(&quot;Repaired &quot; + this.toString());
        }
    }

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="构造器引用" tabindex="-1"><a class="header-anchor" href="#构造器引用" aria-hidden="true">#</a> 构造器引用：</h5><p>它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>final Car car = Car.create( Car::new );
final List&lt; Car &gt; cars = Arrays.asList( car );
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="静态方法引用" tabindex="-1"><a class="header-anchor" href="#静态方法引用" aria-hidden="true">#</a> 静态方法引用</h5><p>它的语法是Class::static_method，实例如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>cars.forEach( Car::collide );
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="特定类的任意对象的方法引用" tabindex="-1"><a class="header-anchor" href="#特定类的任意对象的方法引用" aria-hidden="true">#</a> 特定类的任意对象的方法引用</h5><p>它的语法是Class::method实例如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>cars.forEach( Car::repair );

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="特定对象的方法引用" tabindex="-1"><a class="header-anchor" href="#特定对象的方法引用" aria-hidden="true">#</a> 特定对象的方法引用</h5><p>它的语法是instance::method实例如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>final Car police = Car.create( Car::new ); 
cars.forEach( police::follow );
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="stream" tabindex="-1"><a class="header-anchor" href="#stream" aria-hidden="true">#</a> Stream</h3><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p><p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p><h3 id="什么是-stream" tabindex="-1"><a class="header-anchor" href="#什么是-stream" aria-hidden="true">#</a> 什么是 Stream？</h3><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p><ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li><strong>数据源</strong> 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li><li><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li></ul><p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p><ul><li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li><li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li></ul><h3 id="怎么使用stream" tabindex="-1"><a class="header-anchor" href="#怎么使用stream" aria-hidden="true">#</a> 怎么使用Stream？</h3><p>使用Stream流分为三步：</p><ol><li><p>创建Stream流</p></li><li><p>通过Stream流对象执行中间操作</p></li><li><p>执行最终操作，得到结果</p></li></ol><img src="https://pic1.zhimg.com/80/v2-3c7d8da09743c5b1db451c1b0f5b5ca3_720w.png" style="zoom:80%;"><h3 id="创建流" tabindex="-1"><a class="header-anchor" href="#创建流" aria-hidden="true">#</a> 创建流</h3><p>在 Java 8 中, 集合接口有两个方法来生成流：</p><ul><li><strong>stream()</strong> − 为集合创建串行流。</li><li><strong>parallelStream()</strong> − 为集合创建并行流。</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;); 
List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然大部分情况下<em>stream</em>是容器调用<code>Collection.stream()</code>方法得到的，但<em>stream</em>和<em>collections</em>有以下不同：</p><ul><li><strong>无存储</strong>。<em>stream</em>不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li><li><strong>为函数式编程而生</strong>。对<em>stream</em>的任何修改都不会修改背后的数据源，比如对<em>stream</em>执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新<em>stream</em>。</li><li><strong>惰式执行</strong>。<em>stream</em>上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li><li><strong>可消费性</strong>。<em>stream</em>只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li></ul><p>对<em>stream</em>的操作分为为两类，<strong>中间操作(*intermediate operations*)和结束操作(*terminal operations*)</strong>，二者特点是：</p><ol><li><strong>中间操作总是会惰式执行</strong>，调用中间操作只会生成一个标记了该操作的新<em>stream</em>，仅此而已。</li><li><strong>结束操作会触发实际计算</strong>，计算发生时会把所有中间操作积攒的操作以<em>pipeline</em>的方式执行，这样可以减少迭代次数。计算完成之后<em>stream</em>就会失效。</li></ol><p><code>Stream</code>接口的部分常见方法：</p><table><thead><tr><th>操作类型</th><th>接口方法</th></tr></thead><tbody><tr><td>中间操作</td><td>concat() 、distinct()、 filter() 、flatMap()、 limit() 、map() 、peek() 、skip() 、sorted() 、parallel()、 sequential() 、unordered()</td></tr><tr><td>结束操作</td><td>allMatch()、 anyMatch() 、collect()、 count()、 findAny() 、findFirst() 、forEach() 、forEachOrdered() 、max() 、min() 、noneMatch() 、reduce()、 toArray()</td></tr></tbody></table><p>区分中间操作和结束操作最简单的方法，就是看方法的返回值，返回值为<em>stream</em>的大都是中间操作，否则是结束操作。</p><h3 id="stream方法使用" tabindex="-1"><a class="header-anchor" href="#stream方法使用" aria-hidden="true">#</a> stream方法使用</h3><h3 id="foreach" tabindex="-1"><a class="header-anchor" href="#foreach" aria-hidden="true">#</a> forEach()</h3><p>我们对<code>forEach()</code>方法并不陌生，在<code>Collection</code>中我们已经见过。方法签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作，也就是对元素进行遍历。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 使用Stream.forEach()迭代
Stream&lt;String&gt; stream = Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);
stream.forEach(str -&gt; System.out.println(str));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于<code>forEach()</code>是结束方法，上述代码会立即执行，输出所有字符串。</p><h3 id="filter" tabindex="-1"><a class="header-anchor" href="#filter" aria-hidden="true">#</a> filter()</h3><p><a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/Figures/Stream.filter.png" target="_blank" rel="noopener noreferrer"><img src="https://github.com/CarpenterLee/JavaLambdaInternals/raw/master/Figures/Stream.filter.png" alt="Stream filter" style="zoom:80%;"><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>函数原型为<code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>，作用是返回一个只包含满足<code>predicate</code>条件元素的<code>Stream</code>。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 保留长度等于3的字符串
Stream&lt;String&gt; stream= Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);
stream.filter(str -&gt; str.length()==3)
    .forEach(str -&gt; System.out.println(str));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码将输出为长度等于3的字符串<code>you</code>和<code>too</code>。注意，由于<code>filter()</code>是个中间操作，如果只调用<code>filter()</code>不会有实际计算，因此也不会输出任何信息。</p><h3 id="distinct" tabindex="-1"><a class="header-anchor" href="#distinct" aria-hidden="true">#</a> distinct()</h3><p><a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/Figures/Stream.distinct.png" target="_blank" rel="noopener noreferrer"><img src="https://github.com/CarpenterLee/JavaLambdaInternals/raw/master/Figures/Stream.distinct.png" alt="Stream distinct" style="zoom:80%;"><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>函数原型为<code>Stream&lt;T&gt; distinct()</code>，作用是返回一个去除重复元素之后的<code>Stream</code>。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Stream&lt;String&gt; stream= Stream.of(&quot;wo&quot;, &quot;are&quot;, &quot;family&quot;,&quot;wo&quot;);
stream.distinct()
    .forEach(str -&gt; System.out.println(str));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="sorted" tabindex="-1"><a class="header-anchor" href="#sorted" aria-hidden="true">#</a> sorted()</h3><p>排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为<code>Stream&lt;T&gt;　sorted()</code>和<code>Stream&lt;T&gt;　sorted(Comparator&lt;? super T&gt; comparator)</code>。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Stream&lt;String&gt; stream= Stream.of(&quot;wo&quot;, &quot;are&quot;, &quot;family&quot;);
stream.sorted((str1, str2) -&gt; str1.length()-str2.length())
    .forEach(str -&gt; System.out.println(str));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码将输出按照长度升序排序后的字符串，结果完全在预料之中。</p><h3 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> map()</h3><p><a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/Figures/Stream.map.png" target="_blank" rel="noopener noreferrer"><img src="https://github.com/CarpenterLee/JavaLambdaInternals/raw/master/Figures/Stream.map.png" alt="Stream map"><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>函数原型为<code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)</code>，作用是返回一个对当前所有元素执行执行<code>mapper</code>之后的结果组成的<code>Stream</code>。直观的说，就是对每个元素按照某种操作进行转换，转换前后<code>Stream</code>中元素的个数不会改变，但元素的类型取决于转换之后的类型。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Stream&lt;String&gt; stream　= Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);
stream.map(str -&gt; str.toUpperCase())
    .forEach(str -&gt; System.out.println(str));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码将输出原字符串的大写形式。</p><h3 id="flatmap" tabindex="-1"><a class="header-anchor" href="#flatmap" aria-hidden="true">#</a> flatMap()</h3><p><a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/Figures/Stream.flatMap.png" target="_blank" rel="noopener noreferrer"><img src="https://github.com/CarpenterLee/JavaLambdaInternals/raw/master/Figures/Stream.flatMap.png" alt="Stream flatMap"><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>函数原型为<code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code>，作用是对每个元素执行<code>mapper</code>指定的操作，并用所有<code>mapper</code>返回的<code>Stream</code>中的元素组成一个新的<code>Stream</code>作为最终返回结果。说起来太拗口，通俗的讲<code>flatMap()</code>的作用就相当于把原<em>stream</em>中的所有元素都&quot;摊平&quot;之后组成的<code>Stream</code>，转换前后元素的个数和类型都可能会改变。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(1,2), Arrays.asList(3, 4, 5));
stream.flatMap(list -&gt; list.stream())
    .forEach(i -&gt; System.out.println(i));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中，原来的<code>stream</code>中有两个元素，分别是两个<code>List&lt;Integer&gt;</code>，执行<code>flatMap()</code>之后，将每个<code>List</code>都“摊平”成了一个个的数字，所以会新产生一个由5个数字组成的<code>Stream</code>。所以最终将输出1~5这5个数字。</p><p>以上简单介绍流的一些简单用法，下面介绍下在集合中常用的操作</p><h3 id="规约操作" tabindex="-1"><a class="header-anchor" href="#规约操作" aria-hidden="true">#</a> 规约操作</h3><p>规约操作（<em>reduction operation</em>）又被称作折叠操作（<em>fold</em>），是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。<em>Stream</em>类库有两个通用的规约操作<code>reduce()</code>和<code>collect()</code>，也有一些为简化书写而设计的专用规约操作，比如<code>sum()</code>、<code>max()</code>、<code>min()</code>、<code>count()</code>等。</p><h3 id="reduce" tabindex="-1"><a class="header-anchor" href="#reduce" aria-hidden="true">#</a> reduce()</h3><p>归约Reduce流运算允许我们通过对序列中的元素重复应用合并操作，从而从元素序列中产生一个单一结果。</p><p><em>reduce</em>操作可以实现从一组元素中生成一个值，<code>sum()</code>、<code>max()</code>、<code>min()</code>、<code>count()</code>等都是<em>reduce</em>操作，将他们单独设为函数只是因为常用。<code>reduce()</code>的方法定义有三种重写形式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)
T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)
&lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>标识identity：代表一个元素，它是归约reduce运算的初始值，如果流为空，则为此默认结果。</li><li>accumulator 累加器：具有两个参数的函数：归约reduce运算后的部分结果和流的下一个元素</li><li>combiner 组合器：当归约是并行化或累加器参数的类型与累加器实现的类型不匹配时，用于合并combine归约操作的部分结果的函数</li></ul><p>接口继承关系</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);

@FunctionalInterface
public interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; {
	//两个静态方法，先进行忽略
}

@FunctionalInterface
public interface BiFunction&lt;T, U, R&gt; {
	R apply(T t, U u);
	//一个默认方法，先进行忽略
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法一 reduce(BinaryOperator accumulator)</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
<span class="token comment">//reduce(BinaryOperator&lt;T&gt; accumulator)方法需要一个函数式接口参数`，该函数式接口需要`两个参数`，返回`一个结果`(reduce中</span>
<span class="token comment">//返回的结果会作为下次累加器计算的第一个参数)，也就是`累加器`,最终得到一个`Optional对象</span>
<span class="token comment">//最长单词</span>
<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stream1 <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">&quot;we&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;are&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;family&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> longest <span class="token operator">=</span> stream1<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;=</span>s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>longest<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// family</span>

  #等价于
   <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stream1 <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">&quot;we&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;are&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;family&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> longest <span class="token operator">=</span> stream1<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BinaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法二 reduce(T identity, BinaryOperator accumulator)</strong></p><p>identity参数与Stream中数据同类型，相当于一个的<code>初始值</code>，通过累加器<code>accumulator迭代计算Stream中的数据</code>，得到一个跟Stream中数据相同类型的最终结果。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//求和</span>
<span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">45</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>acc<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> acc <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>

<span class="token comment">//等价于</span>
<span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">45</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">BinaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> acc<span class="token punctuation">,</span> <span class="token class-name">Integer</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> acc <span class="token operator">+</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法三 reduce(U identity,BiFunction&lt;U, ? super T, U&gt; accumulator,BinaryOperator combiner)</strong></p><p>第一个参数：返回实例u，传递你要返回的U类型对象的初始化实例u</p><p>第二个参数：累加器accumulator，可以使用lambda表达式，声明你在u上累加你的数据来源t的逻辑，例如(u,t)-&gt;u.sum(t),此时lambda表达式的行参列表是返回实例u和遍历的集合元素t，函数体是在u上累加t</p><p>第三个参数：参数组合器combiner，接受lambda表达式。参数的数据类型必须为返回数据类型，该参数主要用于合并多个线程的result值。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 求单词长度之和
Stream&lt;String&gt; stream = Stream.of(&quot;a&quot;,&quot;bb&quot;,&quot;ccc&quot;);
Integer lengthSum = stream.reduce(0,
        (sum, str) -&gt; {
            System.out.println(&quot;执行BiFunction&quot;);
            return sum + str.length();
        },
        (a, b) -&gt; {
            System.out.println(&quot;执行BinaryOperator&quot;);
            return a + b;
        });
System.out.println(lengthSum);


//等价于
Stream&lt;String&gt; stream = Stream.of(&quot;a&quot;,&quot;bb&quot;,&quot;ccc&quot;);
Integer lengthSum = stream.reduce(0,
        new BiFunction&lt;Integer, String, Integer&gt;() {
            @Override
            public Integer apply(Integer sum, String str) {
                System.out.println(&quot;执行BiFunction&quot;);
                return sum + str.length();
            }
        },
        new BinaryOperator&lt;Integer&gt;() {
            @Override
            public Integer apply(Integer a, Integer b) {
                System.out.println(&quot;执行BinaryOperator&quot;);
                return a + b;
            }
        });
System.out.println(lengthSum);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>执行BiFunction
执行BiFunction
执行BiFunction
6
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从输出结果可以看出第三个参数并没有执行。</p><p>这是因为Stream是支持并发操作的，为了避免竞争，对于reduce线程都会有独立的result，combiner的作用在于合并每个线程的result得到最终结果。这也说明了了第三个函数参数的数据类型必须为返回数据类型了。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Integer lengthSum = stream.parallel().reduce(0,
        (sum, str) -&gt; {
            System.out.println(&quot;执行BiFunction&quot;);
            return sum + str.length();
        },
        (a, b) -&gt; {
            System.out.println(&quot;执行BinaryOperator&quot;);
            return a + b;
        });
System.out.println(lengthSum);

输出结果

执行BiFunction
执行BiFunction
执行BiFunction
执行BinaryOperator
执行BinaryOperator
6
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="collect" tabindex="-1"><a class="header-anchor" href="#collect" aria-hidden="true">#</a> collect()</h3><p>首先定义个实体类</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@Data
class Apple {

    private String color;
    private Integer weight;

}

@Data
class Person {

    private String firstName, lastName, job, gender;
    private int salary,age;

}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>collect是一个终端操作,它接收的参数是将流中的元素累积到汇总结果的各种方式(称为收集器)</p><p>collect源码</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>使用collect()生成Collection</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 将Stream转换成List或Set
Stream&lt;String&gt; stream = Stream.of(&quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;, &quot;ddd&quot;);
List&lt;String&gt; list = stream.collect(Collectors.toList()); 
Set&lt;String&gt; set = stream.collect(Collectors.toSet()); 

 ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::new));
 HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::new));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>使用collect()生成Map</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Stream&lt;String&gt; stream = Stream.of(&quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;, &quot;ddd&quot;);
// 指定key和value
stream.collect(Collectors.toMap(Function.identity(),String::length));

//分组
Map&lt;Integer, List&lt;Person&gt;&gt; map = listPerson1.stream().collect(Collectors.groupingBy(Person::getSalary));

listPerson1.stream().collect(HashMap::new,(maps,p)-&gt;maps.put(p.getFirstName(),p.getLastName()),Map::putAll);

//toMap()参数一：key值，参数二：value值 参数三：当两个key值相同时，决定保留前一个value值还是后一个value值,key为null
listPerson1.stream()
		   .collect(Collectors.toMap(p -&gt; p.getFirstName(), p -&gt;
           Optional.ofNullable(p.getLastName()).orElse(&quot;value为null加非空检验&quot;), (k1, k2) -&gt; k1));

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>增强版的<code>groupingBy()</code>允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做<strong>上游收集器</strong>，之后执行其他运算的收集器叫做<strong>下游收集器</strong>(<em>downstream Collector</em>)。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//counting方法返回所收集元素的总数
Map&lt;Integer, Long&gt; count = listPerson1.stream().collect(Collectors.groupingBy(Person::getSalary,Collectors.counting()));

//summing方法会对元素求和
Map&lt;Integer, Integer&gt; ageCount = listPerson1.stream().collect(Collectors.groupingBy(Person::getSalary,Collectors.summingInt(Person::getAge)));

//axBy和minBy会接受一个比较器，求最大值，最小值
Map&lt;Integer, Optional&lt;Person&gt;&gt; ageMax =  listPerson1.stream().collect(Collectors.groupingBy(Person::getSalary,Collectors.maxBy(Comparator.comparing(Person::getAge))));

//mapping函数会应用到downstream结果上，并需要和其他函数配合使用
Map&lt;Integer, List&lt;String&gt;&gt; nameMap =  listPerson1.stream().collect(Collectors.groupingBy(Person::getSalary,Collectors.mapping(Person::getFirstName,Collectors.toList())));


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>使用collect()做字符串join</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>String str = Arrays.asList(&quot;voidcc.com&quot;, &quot;voidmvn.com&quot;, &quot;voidtool.com&quot;).stream().collect(Collectors.joining(&quot;,&quot;));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Stream其他用法</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//升序
Stream&lt;Integer&gt; sorted = listPerson1.stream().map(Person::getAge).sorted((x, y) -&gt; x.compareTo(y));
//降序
Stream&lt;Integer&gt; sorted = listPerson1.stream().map(Person::getAge).sorted((x, y) -&gt; y.compareTo(x));
//按key升序
map.entrySet().stream().sorted(Comparator.comparing(e -&gt; e.getKey()));

//最大值
Optional&lt;Person&gt; max = listPerson1.stream().max(Comparator.comparing(Person::getAge));

//Map集合转 List
map.entrySet().stream().sorted(Comparator.comparing(e -&gt; e.getKey()))
                .map(e -&gt; new Apple(e.getKey(), e.getValue())).collect(Collectors.toList())
                .forEach(System.out::println);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: zysspace@163.com">javacode</span><!--]--><!--]--></div></div></footer><nav class="page-nav"><a href="/docs/Java/Java%20SPI%E8%AF%A6%E8%A7%A3.html" class="nav-link prev" aria-label="Java SPI 详解"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><span class="font-icon icon discover" style=""></span>Java SPI 详解</div></a><a href="/docs/Java/jdk%E4%BB%A3%E7%90%86.html" class="nav-link next" aria-label="JDK 代理"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">JDK 代理<span class="font-icon icon discover" style=""></span></div></a></nav><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!--]--><!----><!--]--></div>
    <script type="module" src="/docs/assets/app-cec6d41f.js" defer></script>
  </body>
</html>
