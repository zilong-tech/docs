<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://zilong-tech.github.io/docs/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><meta property="og:site_name" content="子龙技术"><meta property="og:title" content="redis底层数据结构"><meta property="og:description" content="Redis面试中经常被问到，Redis效率为什么这么快，很多同学往往回答：① Redis基于内存操作；② Redis是单线程的，采用了IO多路复用技术； 除了它是内存数据库，使得所有的操作都在内存上进行之外，还有一个重要因素，它实现的数据结构，使得我们对数据进行增删查改操作时，Redis 能高效的处理。 今天来聊下redis的底层数据结构 简单动态字符..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-02-10T09:01:37.000Z"><meta property="article:author" content="程序员子龙"><meta property="article:modified_time" content="2023-02-10T09:01:37.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"redis底层数据结构","image":[""],"dateModified":"2023-02-10T09:01:37.000Z","author":[{"@type":"Person","name":"程序员子龙"}]}</script><title>redis底层数据结构 | 子龙技术</title><meta name="description" content="Redis面试中经常被问到，Redis效率为什么这么快，很多同学往往回答：① Redis基于内存操作；② Redis是单线程的，采用了IO多路复用技术； 除了它是内存数据库，使得所有的操作都在内存上进行之外，还有一个重要因素，它实现的数据结构，使得我们对数据进行增删查改操作时，Redis 能高效的处理。 今天来聊下redis的底层数据结构 简单动态字符...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/docs/assets/style-84ad0583.css" as="style"><link rel="stylesheet" href="/docs/assets/style-84ad0583.css">
    <link rel="modulepreload" href="/docs/assets/app-e6db4a12.js"><link rel="modulepreload" href="/docs/assets/framework-2afc6763.js"><link rel="modulepreload" href="/docs/assets/redis底层数据结构.html-10cda690.js"><link rel="modulepreload" href="/docs/assets/redis底层数据结构.html-8cc2891c.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/docs/" class="brand"><img class="logo" src="/docs/logo.png" alt="子龙技术"><!----><span class="site-name hide-in-pad">子龙技术</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/docs/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="nav-link" aria-label="并发编程"><span class="font-icon icon info" style=""></span>并发编程<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="nav-link" aria-label="网络编程"><span class="font-icon icon info" style=""></span>网络编程<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="分布式"><span class="title"><span class="font-icon icon info" style=""></span>分布式</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/docs/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/" class="nav-link" aria-label="分布式基础"><span class="font-icon icon creative" style=""></span>分布式基础<!----></a></li><li class="dropdown-item"><a href="/docs/zookeeper/" class="nav-link" aria-label="zookeeper"><span class="font-icon icon creative" style=""></span>zookeeper<!----></a></li><li class="dropdown-item"><a href="/docs/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" class="nav-link" aria-label="分布式事务"><span class="font-icon icon creative" style=""></span>分布式事务<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="微服务"><span class="title"><span class="font-icon icon info" style=""></span>微服务</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/docs/SpringBoot/" class="nav-link" aria-label="SpringBoot"><span class="font-icon icon creative" style=""></span>SpringBoot<!----></a></li><li class="dropdown-item"><a href="/docs/SpringCloudAlibaba/" class="nav-link" aria-label="SpringCloudAlibaba"><span class="font-icon icon creative" style=""></span>SpringCloudAlibaba<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/docs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="nav-link" aria-label="设计模式"><span class="font-icon icon info" style=""></span>设计模式<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/Java/" class="nav-link" aria-label="Java"><span class="font-icon icon info" style=""></span>Java<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/JVM/" class="nav-link" aria-label="JVM"><span class="font-icon icon info" style=""></span>JVM<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="数据库"><span class="title"><span class="font-icon icon info" style=""></span>数据库</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/docs/Redis/" class="nav-link active" aria-label="Redis"><span class="font-icon icon info" style=""></span>Redis<!----></a></li><li class="dropdown-item"><a href="/docs/MySQL/" class="nav-link" aria-label="MySQL"><span class="font-icon icon info" style=""></span>MySQL<!----></a></li><li class="dropdown-item"><a href="/docs/Mongodb/" class="nav-link" aria-label="Mongodb"><span class="font-icon icon info" style=""></span>Mongodb<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/docs/Mybatis/" class="nav-link" aria-label="Mybatis"><span class="font-icon icon info" style=""></span>Mybatis<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/Spring/" class="nav-link" aria-label="Spring"><span class="font-icon icon info" style=""></span>Spring<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="消息中间件"><span class="title"><span class="font-icon icon info" style=""></span>消息中间件</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/docs/Kafka/" class="nav-link" aria-label="Kafka"><span class="font-icon icon creative" style=""></span>Kafka<!----></a></li><li class="dropdown-item"><a href="/docs/RocketMQ/" class="nav-link" aria-label="RocketMQ"><span class="font-icon icon creative" style=""></span>RocketMQ<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/docs/%E9%AB%98%E5%B9%B6%E5%8F%91/" class="nav-link" aria-label="高并发"><span class="font-icon icon info" style=""></span>高并发<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/%E9%9D%A2%E8%AF%95/" class="nav-link" aria-label="面试"><span class="font-icon icon info" style=""></span>面试<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/%E5%B7%A5%E5%85%B7/" class="nav-link" aria-label="工具"><span class="font-icon icon info" style=""></span>工具<!----></a></div><div class="nav-item hide-in-mobile"><a href="/docs/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/" class="nav-link" aria-label="开源项目"><span class="font-icon icon info" style=""></span>开源项目<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!----><!----><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/docs/Redis/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85d.html" class="nav-link sidebar-link sidebar-page" aria-label="发布和订阅"><span class="font-icon icon discover" style=""></span>发布和订阅<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/Redis/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html" class="nav-link sidebar-link sidebar-page" aria-label="缓存和数据库一致性解决方案"><span class="font-icon icon discover" style=""></span>缓存和数据库一致性解决方案<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/Redis/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98.html" class="nav-link sidebar-link sidebar-page" aria-label="面试常问使用缓存出现的问题"><span class="font-icon icon discover" style=""></span>面试常问使用缓存出现的问题<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/Redis/%E8%AF%A6%E8%A7%A3redis%E7%9A%84bitmap.html" class="nav-link sidebar-link sidebar-page" aria-label="详解redis的bitmap"><span class="font-icon icon discover" style=""></span>详解redis的bitmap<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/docs/Redis/Redis%20hot%20key%20%E5%8F%91%E7%8E%B0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html" class="nav-link sidebar-link sidebar-page" aria-label="Redis hot key 发现以及解决办法"><span class="font-icon icon discover" style=""></span>Redis hot key 发现以及解决办法<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="redis底层数据结构"><span class="font-icon icon discover" style=""></span>redis底层数据结构<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#简单动态字符串-simple-dynamic-string-sds" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="简单动态字符串(Simple dynamic string,SDS)"><!---->简单动态字符串(Simple dynamic string,SDS)<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#redis数据是怎么存储的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="redis数据是怎么存储的？"><!---->redis数据是怎么存储的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#rehash" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="rehash"><!---->rehash<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#list底层数据结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="list底层数据结构"><!---->list底层数据结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#hash底层数据结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Hash底层数据结构"><!---->Hash底层数据结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#set底层数据结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="set底层数据结构"><!---->set底层数据结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#zset底层数据结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="zset底层数据结构"><!---->zset底层数据结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#总结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="总结"><!---->总结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/docs/Redis/Redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" class="nav-link sidebar-link sidebar-page" aria-label="Redis基础知识"><span class="font-icon icon discover" style=""></span>Redis基础知识<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><span class="font-icon icon discover" style=""></span>redis底层数据结构</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">程序员子龙</span></span><span property="author" content="程序员子龙"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-02-10T09:01:37.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 33 分钟</span><meta property="timeRequired" content="PT33M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><span class="page-category-item category3" role>Redis</span><meta property="articleSection" content="Redis"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容<button class="print-button" title="print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#简单动态字符串-simple-dynamic-string-sds" class="router-link-active router-link-exact-active toc-link level3">简单动态字符串(Simple dynamic string,SDS)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#redis数据是怎么存储的" class="router-link-active router-link-exact-active toc-link level3">redis数据是怎么存储的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#rehash" class="router-link-active router-link-exact-active toc-link level2">rehash</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#list底层数据结构" class="router-link-active router-link-exact-active toc-link level3">list底层数据结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#hash底层数据结构" class="router-link-active router-link-exact-active toc-link level3">Hash底层数据结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#set底层数据结构" class="router-link-active router-link-exact-active toc-link level3">set底层数据结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#zset底层数据结构" class="router-link-active router-link-exact-active toc-link level3">zset底层数据结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html#总结" class="router-link-active router-link-exact-active toc-link level3">总结</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><p>Redis面试中经常被问到，Redis效率为什么这么快，很多同学往往回答：① Redis基于内存操作；② Redis是单线程的，采用了IO多路复用技术；</p><p>除了它是内存数据库，使得所有的操作都在内存上进行之外，还有一个重要因素，它实现的数据结构，使得我们对数据进行增删查改操作时，Redis 能高效的处理。</p><p>今天来聊下redis的底层数据结构</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111292231630.webp" alt=""></p><h3 id="简单动态字符串-simple-dynamic-string-sds" tabindex="-1"><a class="header-anchor" href="#简单动态字符串-simple-dynamic-string-sds" aria-hidden="true">#</a> 简单动态字符串(Simple dynamic string,SDS)</h3><p>C语言字符串使用长度为n+1的字符数组来表示长度为n的字符串，并且字符数组的最后一个元素总是空字符&#39;\0&#39;，因为这种字符串表示方式不能满足Redis对字符串在安全性、效率以及功能方面的要求，所以Redis自己构建了SDS，用于满足其需求。在Redis中，包含字符串值的键值对都是使用SDS实现的，除此之外，SDS还被用于AOF缓冲区、客户端状态的输入缓冲区。</p><p>字符串是Redis中最为常见的数据存储类型，其底层实现是简单动态字符串<strong>sds</strong>(simple dynamic string)，是可以修改的字符串。sds ，<code>Simple</code>的意思是简单，<code>Dynamic</code>即动态，意味着其具有动态增加空间的能力，扩容不需要使用者关心。<code>String</code>是字符串的意思。</p><h4 id="使用sds的好处" tabindex="-1"><a class="header-anchor" href="#使用sds的好处" aria-hidden="true">#</a> 使用SDS的好处</h4><p>1、二进制安全的数据结构</p><p>​ 所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据</p><p>​ sds在Redis中是实现字符串对象的工具，并且完全取代char*..sds是二进制安全的，它可以存储任意二进制数据，不像C语言字符串那 样以‘\0’来标识字符串结束，因为传统C字符串符合ASCII编码，这种编码的操作的特点就是：遇零则止 。即当读一个字符串时，只要遇到’\0’结尾，就认为到达末尾，就忽略’\0’结尾以后的所有字符。因此，如果传统字符串保存图片，视频等二进制文件，操作文件时就被截断了。</p><p>​ SDS表头的buf被定义为字节数组，因为判断是否到达字符串结尾的依据则是表头的len成员，这意味着它可以存放任何二进制的数据和文本数据，包括’\0’</p><p>2、提供了内存预分配机制，避免了频繁的内存分配</p><p>用于字符串增长操作，当字符串增长时，程序会先检查需不需要对SDS空间进行扩展，如果需要扩展，程序不仅会为SDS分配修改所必要的空间，还会为SDS分配额外的未使用空间，额外分配的未使用空间公式如下：</p><p>​ 1）第一次创建len属性等于数据实际大小，free等于0，不做预分配。</p><p>​ 2）修改后如果已有free空间不够且数据小于1M，每次预分配一倍容 量。如原有len=60byte，free=0，再追加60byte，预分配 120byte，总占用空 间：60byte+60byte+120byte+1byte。</p><p>​ 3）修改后如果已有free空间不够且数据大于1MB，每次预分配1MB数据。如原有len=30MB，free=0，当再追加100byte，预分配1MB，总占用空 间：1MB+100byte+1MB+1byte。</p><p>3、兼容C语言的函数库,\0结尾</p><p>4、相比C语言字符串，使获取字符串长度时间复杂度降为O(1)</p><p>C语言字符串不记录自身长度，如果想获取自身长度必须遍历整个字符串，对每个字符进行计数，这个操作时间复杂度是O(n)。相比较而言，Redis程序只要访问SDS的len属性就可以直接获取到字符串长度，时间复杂度为O(1)，确保获取字符串长度不会成为Redis性能瓶颈，比如对字符串键反复执行strlen命令。如：获取“Redis”字符串长度时程序会直接访问len属性即可，该字符串长度为5。</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111281058631.png" alt=""></p><p>5、惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留。</p><p>6、节省内存空间</p><p>SDS 结构中有个 flags 成员变量，表示的是 SDS 类型。</p><p>Redos 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。</p><p>这 5 种类型的主要<strong>区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同</strong></p><h4 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构" aria-hidden="true">#</a> 数据结构</h4><p>Redis中简单动态字符串sds数据结构与API相关文件是：<strong>sds.h</strong>, <strong>sds.c</strong>。</p><p>redis 3.2 以前</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">sdshdr</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">;</span>   <span class="token comment">//buf中已经使用的长度</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> free<span class="token punctuation">;</span>  <span class="token comment">//buf中未使用的长度</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">//柔性数组buf</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>len会占用4个字节，也就是32b，最小值是-2147483648，最大值是2147483647，实际上可能会存储很小的字符串，会造成内存浪费，所以<code>Redis 3.2 版本</code>中，对数据结构做出了修改，针对不同的长度范围定义了不同的结构</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span>sds<span class="token punctuation">;</span>      

<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr5</span> <span class="token punctuation">{</span>     <span class="token comment">// 对应的字符串长度小于 1&lt;&lt;5</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, and 5 msb of string length */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span>     <span class="token comment">// 对应的字符串长度小于 1&lt;&lt;8</span>
    <span class="token class-name">uint8_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>                       <span class="token comment">//目前字符创的长度</span>
    <span class="token class-name">uint8_t</span> alloc<span class="token punctuation">;</span>                                <span class="token comment">//已经分配的总长度 </span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span>                          <span class="token comment">//flag用3bit来标明类型，类型后续解释，其余5bit目前没有使用</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                   <span class="token comment">//柔性数组，以&#39;\0&#39;结尾</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr16</span> <span class="token punctuation">{</span>    <span class="token comment">// 对应的字符串长度小于 1&lt;&lt;16</span>
    <span class="token class-name">uint16_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint16_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr32</span> <span class="token punctuation">{</span>    <span class="token comment">// 对应的字符串长度小于 1&lt;&lt;32</span>
    <span class="token class-name">uint32_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint32_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr64</span> <span class="token punctuation">{</span>    <span class="token comment">// 对应的字符串长度小于 1&lt;&lt;64</span>
    <span class="token class-name">uint64_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint64_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">char</span> <span class="token function">sdsReqType</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> string_size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>string_size <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> SDS_TYPE_5<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>string_size <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> SDS_TYPE_8<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>string_size <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> SDS_TYPE_16<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>LONG_MAX <span class="token operator">==</span> LLONG_MAX<span class="token punctuation">)</span></span></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>string_size <span class="token operator">&lt;</span> <span class="token number">1ll</span><span class="token operator">&lt;&lt;</span><span class="token number">32</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> SDS_TYPE_32<span class="token punctuation">;</span>
    <span class="token keyword">return</span> SDS_TYPE_64<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token keyword">return</span> SDS_TYPE_32<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>alloc - len = free</p><p>用图表示是这样的</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111292238563.webp" alt=""></p><p>结构中的每个成员变量分别介绍下：</p><ul><li><strong>len，SDS 所保存的字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个变量值就行，时间复杂度只需要 O（1）。</li><li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过 <code>alloc - len</code> 计算 出剩余的空间大小，然后用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区益处的问题。</li><li><strong>flags，SDS 类型，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。</li><li><strong>buf[]，字节数组，用来保存实际数据</strong>。不需要用 “\0” 字符来标识字符串结尾了，而是直接将其作为二进制数据处理，可以用来保存图片等二进制数据。它即可以保存文本数据，也可以保存二进制数据，所以叫字节数组会更好点。</li></ul><p>新版带来的好处就是针对长度不同的字符串做了优化，选取不同的数据类型uint8_t或者uint16_t或者uint32_t等来表示长度、一共申请字节的大小等。上面结构体中的__attribute__ ((<strong>packed</strong>)) 设置是告诉编译器取消字节对齐，则结构体的大小就是按照结构体成员实际大小相加得到的。</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111281212462.png" alt=""></p><p>为什么设计成5种数据结构？</p><p><strong>是为了能灵活保存不同大小的字符串，从而有效节省内存空间</strong>。比如，在保存小字符串时，结构头占用空间也比较少。</p><p>除了设计不同类型的结构体，Redis 在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在 struct 声明了 <code>__attribute__ ((packed))</code> ，它的作用是：<strong>告诉编译器取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</p><p>比如，sdshdr16 类型的 SDS，默认情况下，编译器会按照 16 字节对其的方式给变量分配内存，这意味着，即使一个变量的大小不到 16 个字节，编译器也会给它分配 16 个字节。</p><h3 id="redis数据是怎么存储的" tabindex="-1"><a class="header-anchor" href="#redis数据是怎么存储的" aria-hidden="true">#</a> redis数据是怎么存储的？</h3><p>采用的数组+链表，对key进行hash计算，得到hash槽，当有hash冲突时候，采用头插法，产生链表</p><p><img src="https://pic1.zhimg.com/80/v2-00b168d28f81982894aafba8211d3cb3_1440w.png" alt=""></p><p>下面看下具体的数据结构</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">{</span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>                 <span class="token comment">/* The keyspace for this DB    */</span>
    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span>              <span class="token comment">/* Timeout of keys with a timeout set    过期时间字典 */</span>
    dict <span class="token operator">*</span>blocking_keys<span class="token punctuation">;</span>        <span class="token comment">/* Keys with clients waiting for data (BLPOP)*/</span>
    dict <span class="token operator">*</span>ready_keys<span class="token punctuation">;</span>           <span class="token comment">/* Blocked keys that received a PUSH */</span>
    dict <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span>         <span class="token comment">/* WATCHED keys for MULTI/EXEC CAS */</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>                     <span class="token comment">/* Database ID */</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> avg_ttl<span class="token punctuation">;</span>          <span class="token comment">/* Average TTL, just for stats */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> expires_cursor<span class="token punctuation">;</span> <span class="token comment">/* Cursor of the active expire cycle. */</span>
    list <span class="token operator">*</span>defrag_later<span class="token punctuation">;</span>         <span class="token comment">/* List of key names to attempt to defrag one by one, gradually. */</span>
<span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span> <span class="token punctuation">{</span>
    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>
    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// ht[0] , ht[1] =null</span>
    <span class="token keyword">long</span> rehashidx<span class="token punctuation">;</span> <span class="token comment">/* rehashing not in progress if rehashidx == -1 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> iterators<span class="token punctuation">;</span> <span class="token comment">/* number of iterators currently running */</span>
<span class="token punctuation">}</span> dict<span class="token punctuation">;</span>


<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictType</span><span class="token punctuation">{</span>

    <span class="token comment">//计算哈希值的函数</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>hashFunction<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//复制键的函数</span>
    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>keyDup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>private<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//复制值得函数</span>
    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>valDup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>private<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  

    <span class="token comment">//对比键的函数</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>keyCompare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata <span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key2<span class="token punctuation">)</span>

    <span class="token comment">//销毁键的函数</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>keyDestructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>private<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//销毁值的函数</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>valDestructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>private<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  

<span class="token punctuation">}</span>dictType
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以发现，<strong>Redis中有两个哈希表</strong>：</p><ul><li>ht[0]：用于存放<strong>真实</strong>的<code>key-vlaue</code>数据</li><li>ht[1]：用于<strong>扩容(rehash)</strong></li></ul><p>在Redis里边，哈希表使用dictht结构来定义：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* This is our hash table structure. Every dictionary has two of this as we

implement incremental rehashing, for the old to the new table. */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span> <span class="token punctuation">{</span>
 dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span> <span class="token comment">//哈希表数组</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span> <span class="token comment">//  hashtable 容量</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>  <span class="token comment">// size -1，用于计算索引值</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span>  <span class="token comment">// 哈希表已有节点数量，hashtable 元素个数   used / size =1</span>
<span class="token punctuation">}</span> dictht<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>哈希表的节点是怎么实现的</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{</span>
     <span class="token comment">//键</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span> <span class="token comment">//SDS</span>
     <span class="token comment">//值</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>
        <span class="token class-name">uint64_t</span> u64<span class="token punctuation">;</span>
        <span class="token class-name">int64_t</span> s64<span class="token punctuation">;</span>
        <span class="token keyword">double</span> d<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>
      <span class="token comment">//指向下个哈希节点，组成链表</span>
    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>value会进一步封装：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//  redisObject对象 :  string , list ,set ,hash ,zset ...</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>        <span class="token comment">// value的类型 4 bit, sting , hash</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">// 编码格式  4 bit </span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>LRU_BITS<span class="token punctuation">;</span> <span class="token comment">/* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). 
                            *    24 bit 
                            * */</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>           <span class="token comment">// 4 byte  </span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>              <span class="token comment">// 8 byte  总空间:  4 bit + 4 bit + 24 bit + 4 byte + 8 byte = 16 byte  </span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="哈希表hashtable" tabindex="-1"><a class="header-anchor" href="#哈希表hashtable" aria-hidden="true">#</a> <strong>哈希表hashtable</strong></h4><p>哈希表是一种保存键值对（key-value）的数据结构。</p><p>哈希表中的每一个 key 都是独一无二的，程序可以根据 key 查找到与之关联的 value，或者通过 key 来更新 value，又或者根据 key 来删除整个 key-value等等。</p><p>当一个哈希键包含的 key-value 比较多，或者 key-value 中元素都是比较长多字符串时，Redis 就会使用哈希表作为哈希键的底层实现。</p><p>Hash 表优点在于，它<strong>能以 O(1) 的复杂度快速查询数据</strong>。主要是通过 Hash 函数的计算，就能定位数据在表中的位置，紧接着可以对数据进行操作，这就使得数据操作非常快。</p><p>但是存在的风险也是有，在哈希表大小固定的情况下，随着数据不断增多，那么<strong>哈希冲突</strong>的可能性也会越高。</p><p>解决哈希冲突的方式，有很多种。<strong>Redis 采用了链式哈希</strong>，在不扩容哈希表的前提下，将具有相同哈希值的数据链接起来，以便这些数据在表中仍然可以被查询到。</p><h4 id="哈希冲突" tabindex="-1"><a class="header-anchor" href="#哈希冲突" aria-hidden="true">#</a> 哈希冲突</h4><p>哈希表实际上是一个数组，数组里多每一个元素就是一个哈希桶。</p><p>当一个键值对的键经过 Hash 函数计算后得到哈希值，再将(哈希值 % 哈希表大小)取模计算，得到的结果值就是该 key-value 对应的数组元素位置，也就是第几个哈希桶。</p><p>举个例子，有一个可以存放 8 个哈希桶的哈希表。key1 经过哈希函数计算后，再将「哈希值 % 8 」进行取模计算，结果值为 1，那么就对应哈希桶 1，类似的，key9 和 key10 分别对应哈希桶 1 和桶 6。</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111292307150.webp" alt=""></p><p>此时，key1 和 key9 对应到了相同的哈希桶中，这就发生了哈希冲突。</p><p>因此，<strong>当有两个以上数量的 kay 被分配到了哈希表数组的同一个哈希桶上时，此时称这些 key 发生了冲突。</strong></p><h4 id="链式哈希" tabindex="-1"><a class="header-anchor" href="#链式哈希" aria-hidden="true">#</a> 链式哈希</h4><p>Redis 采用了「<strong>链式哈希</strong>」的方法来解决哈希冲突。</p><p>实现的方式就是每个哈希表节点都有一个 next 指针，多个哈希表节点可以用 next 指针构成一个单项链表，<strong>被分配到同一个哈希桶上的多个节点可以用这个单项链表连接起来</strong>，这样就解决了哈希冲突。</p><p>还是用前面的哈希冲突例子，key1 和 key9 经过哈希计算后，都落在同一个哈希桶，链式哈希的话，key1 就会通过 next 指针指向 key9，形成一个单向链表。</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111292308420.webp" alt=""></p><p>不过，链式哈希局限性也很明显，随着链表长度的增加，在查询这一位置上的数据的耗时就会增加，毕竟链表的查询的时间复杂度是 O（n）。</p><p>要想解决这一问题，就需要进行 rehash，就是对哈希表的大小进行扩展。</p><p>接下来，看看 Redis 是如何实现的 rehash 的。</p><h2 id="rehash" tabindex="-1"><a class="header-anchor" href="#rehash" aria-hidden="true">#</a> rehash</h2><p>rehash就是扩容，在对哈希表进行扩展或者收缩操作时，reash过程并不是一次性地完成的，而是<strong>渐进式</strong>地完成的。<strong>Redis是专门使用一个哈希表来做rehash的</strong>。</p><p>Redis 会使用了两个全局哈希表进行 rehash。</p><p>在正常服务请求阶段，插入的数据，都会写入到「哈希表 1」，此时的「哈希表 2 」 并没有被分配空间。</p><p>Redis在rehash时采取渐进式的原因：<strong>数据量如果过大的话，一次性rehash会有庞大的计算量，这很可能导致服务器一段时间内停止服务</strong>。</p><p>1、在字典中维持一个索引计数器变量rehashidx，并将设置为0，表示rehash开始。给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍。</p><p>2、在rehash期间每次对字典进行增加、查询、删除和更新操作时，<strong>除了执行指定命令外</strong>；还会将ht[0]中rehashidx索引上的值<strong>rehash到ht[1]</strong>，操作完成后rehashidx+1。</p><p>3、字典操作不断执行，最终在某个时间点，所有的键值对完成rehash，这时<strong>将rehashidx设置为-1，表示rehash完成</strong></p><p>4、在渐进式rehash过程中，字典会同时使用两个哈希表ht[0]和ht[1]，所有的更新、删除、查找操作也会在两个哈希表进行。例如要查找一个键的话，<strong>服务器会优先查找ht[0]，如果不存在，再查找ht[1]</strong>，诸如此类。此外当执行<strong>新增操作</strong>时，新的键值对<strong>一律保存到ht[1]</strong>，不再对ht[0]进行任何操作，以保证ht[0]的键值对数量只减不增，直至变为空表。</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111292312687.webp" alt=""></p><h4 id="rehash-触发条件" tabindex="-1"><a class="header-anchor" href="#rehash-触发条件" aria-hidden="true">#</a> rehash 触发条件</h4><p>介绍了 rehash 那么多，还没说什么时情况下会触发 rehash 操作呢？</p><p>rehash 的触发条件跟**负载因子（load factor）**有关系。</p><p>负载因子可以通过下面这个公式计算：</p><p>负载因子 = 哈希表已保存节点数量 / 哈希表大小</p><p>触发 rehash 操作的条件，主要有两个：</p><ul><li><p><strong>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</strong></p></li><li><p><strong>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</strong></p></li></ul><p>我们看下整体的结构</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111281850445.png" alt=""></p><p>Redis 底层的数据结构一共有 6 种，它和数据类型对应关系也如下图：</p><img src="https://pic3.zhimg.com/80/v2-0911c4ab11abb6ee12122643ee59479d_720w.png" style="zoom:50%;"><p>可以看到，有些数据类型可以由两种 数据结构实现：</p><ul><li>List 数据类型底层数据结构由「双向链表」或「压缩表列表」实现；</li><li>Hash 数据类型底层数据结构由「压缩列表」或「哈希表」实现；</li><li>Set 数据类型底层数据结构由「哈希表」或「整数集合」实现；</li><li>Zset 数据类型底层数据结构由「压缩列表」或「跳表」实现；</li></ul><h3 id="list底层数据结构" tabindex="-1"><a class="header-anchor" href="#list底层数据结构" aria-hidden="true">#</a> list底层数据结构</h3><p>List是一个有序(按加入的时序排序)的数据结构，Redis采用quicklist（双端链表） 和 ziplist 作为List的底层实现。</p><p>压缩列表(ziplist)是Redis为了节约内存而开发的，是由一系列的<strong>特殊编码的连续内存块</strong>组成的<strong>顺序性</strong>数据结构。</p><h4 id="ziplist" tabindex="-1"><a class="header-anchor" href="#ziplist" aria-hidden="true">#</a> ziplist</h4><p>ziplist是由一系列特殊编码的连续内存块组成的顺序存储结构，类似于数组，ziplist在内存中是连续存储的，但是不同于数组，为了节省内存 ziplist的每个元素所占的内存大小可以不同（数组中叫元素，ziplist叫节点entry，下文都用“节点”），每个节点可以用来存储一个整数或者一个字符串。 <img src="https://gitee.com/zysspace/pic/raw/master/images/202111282149414.png" alt=""></p><p>zlbytes: ziplist的长度（单位: 字节)，是一个32位无符号整数，记录整个压缩列表占用对内存字节数； zltail: 记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；，反向遍历ziplist或者pop尾部节点的时候有用。 zllen: ziplist的节点（entry）个数 entry: 节点 zlend: 值为0xFF，用于标记ziplist的结尾</p><p><strong>ziplist将一些必要的偏移量信息记录在了每一个节点里，使之能跳到上一个节点或下一个节点。</strong></p><p>节点的布局(entry)</p><p>每个节点由三部分组成：prerawlen、len、data</p><ul><li>prerawlen: 记录上一个节点的长度，为了方便反向遍历ziplist</li><li>len: entry中数据的长度</li><li>data: 当前节点的值，可以是数字或字符串</li></ul><p>压缩列表从表尾节点<strong>倒序遍历</strong>，首先指针通过zltail偏移量指向表尾节点，然后通过指向<strong>节点记录的前一个节点的长度依次向前遍历访问整个压缩列表</strong>。</p><p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。</p><h4 id="连锁更新" tabindex="-1"><a class="header-anchor" href="#连锁更新" aria-hidden="true">#</a> 连锁更新</h4><p>压缩列表除了查找复杂度高的问题，压缩列表在插入元素时，如果内存空间不够了，压缩列表还需要重新分配一块连续的内存空间，而这可能会引发<strong>连锁更新</strong>的问题。</p><p>压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：</p><ul><li>如果前一个<strong>节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li><li>如果前一个<strong>节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li></ul><p>现在假设一个压缩列表中有多个连续的、长度在 250～253 之间的节点，如下图：</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111292258386.webp" alt=""></p><p>因为这些节点长度值小于 254 字节，所以 prevlen 属性需要用 1 字节的空间来保存这个长度值。</p><p>这时，如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即新节点将成为 e1 的前置节点，如下图：</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111292259345.webp" alt=""></p><p>因为 e1 节点的 prevlen 属性只有 1 个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作，并将 e1 节点的 prevlen 属性从原来的 1 字节大小扩展为 5 字节大小。</p><p>多米诺牌的效应就此开始。</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111292300101.webp" alt=""></p><p>e1 原本的长度在 250～253 之间，因为刚才的扩展空间，此时 e1 的长度就大于等于 254 了，因此原本 e2 保存 e1 的 prevlen 属性也必须从 1 字节扩展至 5 字节大小。</p><p>正如扩展 e1 引发了对 e2 扩展一样，扩展 e2 也会引发对 e3 的扩展，而扩展 e3 又会引发对 e4 的扩展…. 一直持续到结尾。</p><p><strong>这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」</strong>，就像多米诺牌的效应一样，第一张牌倒下了，推动了第二张牌倒下；第二张牌倒下，又推动了第三张牌倒下….</p><p>连锁更新一旦发生，就会导致压缩列表 占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能。</p><p>所以说，虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，压缩列表就会面临「连锁更新」的风险。</p><p>因此，<strong>压缩列表只会用于保存的节点数量不多的场景</strong>，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p><p><strong>ziplist 的优点是内存紧凑，访问效率高，缺点是更新效率低，并且数据量较大时，可能导致大量的内存复制</strong></p><h4 id="quicklist" tabindex="-1"><a class="header-anchor" href="#quicklist" aria-hidden="true">#</a> quicklist</h4><p>quicklist 是一个双向链表，并且是一个 ziplist 的双向链表，也就是说 quicklist 的每个节点都是一个 ziplist。quicklist是由ziplist组成的双向链表，链表中的每一个节点都以压缩列表ziplist的结构保存着数据，而ziplist有多个entry节点，保存着数据。相当与一个quicklist节点保存的是<strong>一片数据，而不再是一个数据</strong>。</p><ul><li><p>quicklist 是一个双向链表，head、tail分别指向头尾节点</p></li><li><p>quicklistNode 是双向链表的节点，prev、next分别指向前驱、后继结点</p></li><li><p>quicklistNode.zl 指向一个ziplist（或者quicklistLZF结构）</p></li><li><p>quicklistEntry 包裹着list的每一个值，作为ziplist的一个节点</p></li><li><p>quicklist宏观上是一个双向链表，因此，它具有一个双向链表的有点，进行插入或删除操作时非常方便，虽然复杂度为O(n)，但是不需要内存的复制，提高了效率，而且访问两端元素复杂度为O(1)。</p></li><li><p>quicklist微观上是一片片entry节点，每一片entry节点内存连续且顺序存储，可以通过二分查找以 log2(n)log2(n) 的复杂度进行定位。</p></li></ul><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111282203258.png" alt=""></p><p>可以通过设置每个ziplist的最大容量，quicklist的数据压缩范围，提升数据存取效率</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>list-max-ziplist-size  -2        //  单个ziplist节点最大能存储  8kb  ,超过则进行分裂,将数据存储在新的ziplist节点中
list-compress-depth  1        //  0 代表所有节点，都不进行压缩，1， 代表从头节点往后走一个，尾节点往前走一个不用压缩，其他的全部压缩，2，3，4 ... 以此类推
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="hash底层数据结构" tabindex="-1"><a class="header-anchor" href="#hash底层数据结构" aria-hidden="true">#</a> Hash底层数据结构</h3><p>Hash 数据结构底层实现为一个字典( dict ),也是RedisBb用来存储K-V的数据结构,当数据量比较小，或者单个元素比较小时，底层用ziplist存储，数据大小和元素数量阈值可以通过如下参数设置。</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111282226814.png" alt=""></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>hash-max-ziplist-entries  <span class="token number">512</span>    //  ziplist 元素个数超过 <span class="token number">512</span> ，将改为hashtable编码 
hash-max-ziplist-value    <span class="token number">64</span>      //  单个元素大小超过 <span class="token number">64</span> byte时，将改为hashtable编码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>hashtable上文讲过了，这里不再赘述了。</p><p><img src="https://pica.zhimg.com/80/v2-100b1a12f6ae0b1e35bc4670fa468c37_1440w.png" alt=""></p><h3 id="set底层数据结构" tabindex="-1"><a class="header-anchor" href="#set底层数据结构" aria-hidden="true">#</a> set底层数据结构</h3><p>Set 为无序的，自动去重的集合数据类型，Set 数据结构底层实现为一个value 为 null 的 字典( dict ),当数据可以用整形表示时，Set集合将被编码为intset数据结构。两个条件任意满足时Set将用hashtable存储数据。1， 元素个数大于 set-max-intset-entries , 2 ， 元素无法用整形表示</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>set-max-intset-entries <span class="token number">512</span>       // intset 能存储的最大元素个数，超过则用hashtable编码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://pica.zhimg.com/80/v2-f1e0f092b0e310810863390afb5de174_1440w.png" alt=""></p><h3 id="zset底层数据结构" tabindex="-1"><a class="header-anchor" href="#zset底层数据结构" aria-hidden="true">#</a> zset底层数据结构</h3><p>ZSet 为有序的，自动去重的集合数据类型，ZSet 数据结构底层实现为 字典(dict) + 跳表(skiplist) ,当数据比较少时，用ziplist编码结构存储。</p><p><img src="https://pica.zhimg.com/80/v2-bf6176ad3443a8198bc563ed0312507a_720w.png" alt=""></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>zset-max-ziplist-entries  128    // 元素个数超过128 ，将用skiplist编码
zset-max-ziplist-value     64     //  单个元素大小超过 64 byte, 将用 skiplist编码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="跳跃表-shiplist" tabindex="-1"><a class="header-anchor" href="#跳跃表-shiplist" aria-hidden="true">#</a> 跳跃表(shiplist)</h4><p>跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他的节点指针，从而达到快速访问节点的目的。</p><p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员(member)是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构</p><p>Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。</p><p>我们先来看一下一张完整的跳跃表的图</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111302131764.png" alt=""></p><p>图片最左边的是zskiplist结构，该结构包含以下属性：</p><p>header：指向跳跃表的表头节点</p><p>tail：指向跳跃表的表尾节点</p><p>level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）</p><p>length：记录跳跃表的长度，目前跳跃表包含的节点数量(表头节点不计算在内)</p><p>位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性：</p><p>层（level）：节点中用LI、L2、L3等字样标记节点的各个层，L1代表第一层，L2 代表第二层，以此类推。</p><p>每个层都带有两个属性：前进指针和跨度。前进指针用于 访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是 跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</p><p>后退指针 （backward）：节点中用BW字样标记节点的后退指针，它指向位于当前节 点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</p><p>分值(score)：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中， 节点按各自所保存的分值从小到大排列。</p><p>成员对象(obj )：各个节点中的。o1、o2和o3是节点所保存的成员对象。</p><blockquote><p>注意:表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不 过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表头节点的各个层。</p></blockquote><h4 id="跳跃表节点" tabindex="-1"><a class="header-anchor" href="#跳跃表节点" aria-hidden="true">#</a> 跳跃表节点</h4><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* ZSETs use a specialized version of Skiplists */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">{</span>
    robj <span class="token operator">*</span>obj<span class="token punctuation">;</span>  <span class="token comment">/*成员对象*/</span>
    <span class="token keyword">double</span> score<span class="token punctuation">;</span>   <span class="token comment">/*分值*/</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span> <span class="token comment">/*后退指针*/</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">{</span> <span class="token comment">/*层*/</span>
        <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>  <span class="token comment">/*前进指针*/</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span>  <span class="token comment">/*跨度*/</span>
    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>1、层 level 跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。</p><p>每次创建一个新跳跃表节点的时候，程序根据幂次定律(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。</p><p>下图分别展示了三个高度为1层、3层和5层的节点，因为C语言的数组索引总是从0开始的，所以节点的第一层是level[0]，而第二层是level[1]，依次类推。 <img src="https://gitee.com/zysspace/pic/raw/master/images/202111302207836.png" alt=""></p><p>2、前进指针 forward</p><p>每个层都有一个指向表尾方向的前进指针(level[i].forward属性)，用于从表头向表尾方向访问节点。下图用虚线表示出了程序从表头向表尾方向，遍历跳跃表中所有节点的路径：</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111302212383.png" alt=""></p><ul><li>迭代程序首先访问跳跃表的第一个节点(表头)，然后从第四层的前进指针移动到表中的第二个节点。</li><li>在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点。</li><li>在第三个节点时，程序同样沿着第二层的前进指针移动到表中的第四个节点。</li><li>当程序再次沿着第四个节点的前进指针移动时，它碰到一个NULL，程序知道这时已经到达了跳跃表的表尾，于是结束这次遍历。</li></ul><p>3、跨度 level</p><p>层的跨度(level[i].span属性)用于记录两个节点之间的距离：</p><ul><li>两个节点之间的跨度越大，它们相距得就越远。</li><li>指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。</li></ul><p>遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位(rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p><p>举个例子，下图用虚线标记了在跳跃表中查找分值为3.0、成员对象为o3的节点时，沿途经历的层：查找的过程只经过了一个层，并且层的跨度为3，所以目标节点在跳跃表中的排位为3。</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111302218869.png" alt=""></p><p>4、后退指针 backward</p><p>节点的后退指针(backward属性)用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p><p>下图用虚线展示了如何从表尾向表头遍历跳跃表中的所有节点：程序首先通过跳跃表的tail指针访问表尾节点，然后通过后退指针访问倒数第二个节点，之后再沿着后退指针访问倒数第三个节点，再之后遇到指向NULL的后退指针，于是访问结束。 <img src="https://gitee.com/zysspace/pic/raw/master/images/202111302223884.png" alt=""></p><p>5、分值和成员</p><p>节点的分值(score属性)是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。</p><p>节点的成员对象(obj属性)是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。</p><p>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分至相同的节点将按照成员对象在字典中的大小来进行排序，成员对象较小的节点会排在前面(靠近表头的方向)，而成员对象较大的节点则会排在后面(靠近表尾的方向)。</p><p>举个例子，在下图中所示的跳跃表中，三个跳跃表节点都保存了相同的分值10086.0，但保存成员对象o1的节点却排在保存成员对象o2和o3的节点的前面，而保存成员对象o2的节点又排在保存成员对象o3的节点之前，由此可见，o1、o2、o3三个成员对象在字典中的排序为o1&lt;=o2&lt;=o3。 <img src="https://gitee.com/zysspace/pic/raw/master/images/202111302227501.png" alt=""></p><h4 id="跳跃表" tabindex="-1"><a class="header-anchor" href="#跳跃表" aria-hidden="true">#</a> 跳跃表</h4><p>zskiplist结构的定义：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplist</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>    <span class="token comment">//header指向跳跃表的表头节点，tail指向跳跃表的表尾节点</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>   <span class="token comment">//记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</span>
    <span class="token keyword">int</span> level<span class="token punctuation">;</span>  <span class="token comment">//记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</span>
<span class="token punctuation">}</span> zskiplist<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>仅靠多个跳跃表节点就可以组成一个跳跃表，如下图所示：</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111302230413.png" alt=""></p><p>但通过使用一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或者快速地获取跳跃表节点的数量(也即是跳跃表的长度)等信息，如下图所示：</p><p><img src="https://gitee.com/zysspace/pic/raw/master/images/202111302232046.png" alt=""></p><p>header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为0(1)。</p><p>通过使用length属性来记录节点的数量，程序可以在0(1)复杂度内返回跳跃表的长度。</p><p>level属性则用于在0 (1)复杂度内获取跳跃表中层高最大的那个节点的层数量</p><blockquote><p>注意 表头节点的层高并不计算在内。</p></blockquote><p><strong>时间复杂度</strong></p><p>学过数据结构的都知道，在中查询一个元素的时间复杂度为O(n)，即使该单链表是有序的，我们也不能通过2分的方式缩减时间复杂度。</p><p><img src="https://pica.zhimg.com/80/v2-4dc30e44108a9247e6a02c34f4b04d26_1440w.png" alt="img"></p><p>如上图，我们要查询元素为55的结点，必须从头结点，循环遍历到最后一个节点，不算-INF(负无穷)一共查询8次。那么用什么办法能够用更少的次数访问55呢？最直观的，当然是新开辟一条捷径去访问55。</p><p><img src="https://pic1.zhimg.com/80/v2-54510a4d4fee4831a76a2cf49008a236_1440w.png" alt="img"></p><p>如上图，我们要查询元素为55的结点，只需要在L2层查找4次即可。在这个结构中，查询结点为46的元素将耗费最多的查询次数5次。即先在L2查询46，查询4次后找到元素55，因为链表是有序的，46一定在55的左边，所以L2层没有元素46。然后我们退回到元素37，到它的下一层即L1层继续搜索46。非常幸运，我们只需要再查询1次就能找到46。这样一共耗费5次查询。</p><p>那么，如何才能更快的搜寻55呢？有了上面的经验，我们就很容易想到，再开辟一条捷径。</p><p><img src="https://pica.zhimg.com/80/v2-36a69a7f97e1033bbdd398d275854f63_1440w.png" alt="img"></p><p>如上图，我们搜索55只需要2次查找即可。这个结构中，查询元素46仍然是最耗时的，需要查询5次。即首先在L3层查找2次，然后在L2层查找2次，最后在L1层查找1次，共5次。很显然，这种思想和2分非常相似，那么我们最后的结构图就应该如下图。</p><p><img src="https://pic2.zhimg.com/80/v2-baa43d44a1c639634c26b39b737c581a_1440w.png" alt="img"></p><p>我们可以看到，最耗时的访问46需要6次查询。即L4访问55，L3访问21、55，L2访问37、55，L1访问46。我们直觉上认为，这样的结构会让查询有序链表的某个元素更快。那么究竟算法复杂度是多少呢？</p><p>​ 如果有n个元素，因为是2分，所以层数就应该是log n层 (本文所有log都是以2为底)，再加上自身的1层。以上图为例，如果是4个元素，那么分层为L3和L4，再加上本身的L2，一共3层；如果是8个元素，那么就是3+1层。最耗时间的查询自然是访问所有层数，耗时logn+logn，即2logn。为什么是2倍的logn呢？我们以上图中的46为例，查询到46要访问所有的分层，每个分层都要访问2个元素，中间元素和最后一个元素。所以时间复杂度为O(logn)。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>跳跃表是有序集合的底层实现之一。</p><p>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist 用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表 示用跃表节点。</p><p>每个跳跃表节点的层高都是1至32之间的随机数。</p><p>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是 唯一的。</p><p>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小 进行排序。</p></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: zysspace@163.com">javacode</span><!--]--><!--]--></div></div></footer><nav class="page-nav"><a href="/docs/Redis/Redis%20hot%20key%20%E5%8F%91%E7%8E%B0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html" class="nav-link prev" aria-label="Redis hot key 发现以及解决办法"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><span class="font-icon icon discover" style=""></span>Redis hot key 发现以及解决办法</div></a><a href="/docs/Redis/Redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" class="nav-link next" aria-label="Redis基础知识"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">Redis基础知识<span class="font-icon icon discover" style=""></span></div></a></nav><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!--]--><!----><!--]--></div>
    <script type="module" src="/docs/assets/app-e6db4a12.js" defer></script>
  </body>
</html>
